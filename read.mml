use (
	. "lang"
	  "parse"
	  "errors"
	  "io"
	  "paths"
	  "structs"
	  "codetree"
)

fn readModule(reading, modules, path) {
	if has(path, reading) {
		return error("circular module reference")
	}

	if has(path, modules) {
		return modules
	}

	let moduleCode = path -> errors.pass(
		bind(formats, "%s.mml")
		io.readFile
		parse.do
	)
	check moduleCode

	let usePaths = moduleCode
		-> codetree.filter(is({type: "use"}))
		-> map(structs.get("path"))
		-> map(structs.get("value"))
	
	let readingUses = {reading..., [path]: true}
	return fold(
		fn (path, modules) isError(modules) ?
			modules :
			readModule(readingUses, modules, path)
		{modules..., [path]: moduleCode}
		usePaths
	)
}

fn setPaths(modules)
	modules
	-> keys
	-> fold(
		fn (path, withPath) {
			withPath...
			[path]: {
				modules[path]...
				path: path
			}
		}
		{}
	)

fn setUsedModules(setting, done, path, modules) {
	if has(path, setting) {
		return error("circular module reference")
	}

	if has(path, done) {
		return done
	}

	if !has(path, modules) {
		return error("missing module")
	}

	let uses = modules[path] -> codetree.filter(is({type: "use"})) -> map(structs.get("path")) -> map(structs.get("value"))
	let settingUses = {setting..., [path]: true}
	let nextDone = fold(
		fn (u, done)
			isError(done) ?
			done :
			setUsedModules(settingUses, done, u, modules)
		done
		uses
	)
	check nextDone

	return {
		nextDone...
		[path]: codetree.edit(fn (c) is({type: "use"}, c) ? {c..., module: nextDone[c.path.value]} : c, modules[path])
	}
}

export fn do(path) path -> errors.pass(
	paths.normalize
	paths.trimExtension
	readModule({}, {})
	setPaths
	setUsedModules({}, {}, path)
	structs.get(path)
)

export fn fromCode(entryPath, modules) modules -> errors.pass(
	structs.map(parse.do)
	setPaths
	setUsedModules({}, {}, entryPath)
	structs.get(entryPath)
)
