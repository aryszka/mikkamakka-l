fn (
	fold(f, i, l)            len(l) == 0 ? i : fold(f, f(l[0], i), l[1:])
	foldr(f, i, l)           len(l) == 0 ? i : f(l[0], foldr(f, i, l[1:]))
	map(m, l)                fold(fn (c, r) [r..., m(c)], [], l)
	filter(p, l)             fold(fn (c, r) p(c) ? [r..., c] : r, [], l)
	not(x)                   !x
	yes(x)                   x
	ifErr(mod, f)            fn~ (a) mod(isError(a)) ? f(a) : a
	passErr(f)               ifErr(not, f)
	onlyErr(f)               ifErr(yes, f)
	anyErr(l)                fold(fn (c, r) isError(r) ? r : isError(c) ? c : [r..., c], [], l)
	firstOr(v, l)            len(l) > 0 ? l[0] : v
	join(j, s)               len(s) < 2 ? firstOr("", s) : s[0] + j + join(j, s[1:])
	joins(j, ...s)           join(j, s)
	joinTwo(j, left, right)  joins(j, left, right)
	destruct(s)              s -> keys -> map(fn (key) [key, s[key]])
	formats(f, ...a)         format(f, a)
	formatOne(f, a)          formats(f, a)
	passErrFormat(fmt, ...p) p -> anyErr -> passErr(format(fmt))
	notEmpty(l)              l -> filter(fn (s) s != "")
)

fn counter () {
	let ~ c -1
	return fn~ () {
		c = c + 1
		return c
	}
}

let enum counter

// TODO: should be a builtin fake function
fn~ log(...a) {
	a -> map(string) -> join(" ") -> stderr
	"\n" -> stderr
	return len(a) == 0 ? "" : a[len(a) - 1]
}

fn~ (
	readAll(input) input(-1)
	read(input)    input -> readAll -> passErr(parse)
)

fn escape(s) {
	if s == "" {
		return ""
	}

	let ~ first s[0]
	switch first {
	case "\b":
		first = "\\b"
	case "\f":
		first = "\\f"
	case "\n":
		first = "\\n"
	case "\r":
		first = "\\r"
	case "\t":
		first = "\\t"
	case "\v":
		first = "\\v"
	case "\"":
		first = "\\\""
	case "\\":
		first = "\\\\"
	}

	return first + escape(s[1:])
}

let (
	compileInt   string
	compileFloat string
	compileBool  string
)

fn (
	mapCompile(l)         l -> map(compile) -> anyErr
	mapCompileJoin(j, l)  l -> mapCompile -> passErr(join(j))
	compileComment(_)     ""
	compileString(s)      formats("\"%s\"", escape(s))
	compileSymbol(s)      formats("_%s", s.name)
	compileEntry(e)       passErrFormat("\"%s\":%s", compile(e.key), compile(e.value))
	compileEntries(e)     mapCompileJoin(",", e)
	compileStructure(s)   passErrFormat("map[string]interface{}{%s}", compileEntries(s.entries))
	compileCond(c)        c.ternary ? compileTernary(c) : compileIf(c)
	compileIndexer(i)     passErrFormat("%s[%s]", compile(i.expression), compile(i.index))
	compileSpread(s)      passErrFormat("%s...", compile(s.value))
	compileArgs(i)        mapCompileJoin(",", i)
	compileApplication(a) passErrFormat("%s(%s)", compile(a.function), compileArgs(a.args))
	compileCase(c)        passErrFormat("case %s:\n%s", compile(c.expression), compile(c.body))
	compileSend(s)        passErrFormat("%s <- %s", compile(s.channel), compile(s.value))
	compileReceive(r)     passErrFormat("<- %s", compile(r.channel))
	compileGo(g)          passErrFormat("go %s", compile(g.application))
	compileDefer(d)       passErrFormat("defer %s", compile(d.application))
	compileDefinition(d)  passErrFormat("var _%s = %s", d.symbol, compile(d.expression))
	compileDefinitions(l) mapCompileJoin(";\n", l.definitions)
	compileAssign(a)      passErrFormat("%s = %s", compile(a.capture), compile(a.value))
	compileAssigns(l)     mapCompileJoin(";\n", l.assignments)
	compileStatements(s)  s -> mapCompile -> passErr(notEmpty) -> passErr(join(";\n"))
	compileRet(r)         passErrFormat("return %s", compile(r.value))
	compileControl(c)     c.control == breakControl ? "break" : "continue"
	compileModule(m)      compileStatements(m.statements)
)

fn compileList(l)
	l.values
	-> mapCompile
	-> passErr(map(fn (item) len(item) > 3 && item[len(item) - 3:] == "..." ? {spread: item} : item))
	-> passErr(fold(fn (item, appends) {
		let i len(appends) - 1
		switch {
		case i < 0 && isString(item):
			return [{simple: [item]}]
		case i < 0 && has("spread", item):
			return [{spread: [item.spread]}]
		case has("simple", appends[i]) && isString(item):
			return [appends[:i]..., {simple: [appends[i].simple..., item]}]
		case has("simple", appends[i]) && has("spread", item):
			return [appends..., {spread: [item.spread]}]
		case has("spread", appends[i]) && isString(item):
			return [appends..., {simple: [item]}]
		case has("spread", appends[i]) && has("spread", item):
			return [appends[:i]..., {spread: [appends[i].spread..., item.spread]}]
		}
	}, []))
	-> passErr(fold(
		fn (current, code) has("simple", current) ?
			formats("append(%s, %s)", code, join(", ", current.simple)) :
			fold(fn (spread, code) formats("append(%s, %s)", code, spread), code, current.spread)
		"[]interface{}{}"
	))

fn compileParamList(params, collectParam)
	params
	-> map(formatOne("_%s"))
	-> join(",")
	-> fn (p) p == "" ? "" : formats("%s interface{}", p)
	-> fn (p) collectParam == "" ?
		p :
		p == "" ?
			formats("%s ...interface{}", collectParam) :
			formats("%s, %s ...interface{}", p, collectParam)

fn compileFunction(f) passErrFormat(
	has("type", f.statement) && f.statement.type == "statement-list" ?
		"func(%s) interface{} {%s; return nil}" :
		"func(%s) interface{} { return %s }"
	compileParamList(f.params, f.collectParam)
	compile(f.statement)
)

fn compileRangeExpression(e) passErrFormat(
	"%s:%s"
	has("from", e) ? compile(e.from) : ""
	has("to", e) ? compile(e.to) : ""
)

let (
	unaryOp    enum()
	binaryNot  unaryOp()
	plus       unaryOp()
	minus      unaryOp()
	logicalNot unaryOp()
)

fn compileUnaryOp(o) {
	switch o {
	case binaryNot:
		return "^"
	case plus:
		return "+"
	case minus:
		return "-"
	case logicalNot:
		return "!"
	default:
		return error(formats("unsupported code: %v"), o)
	}
}

fn compileUnary(u) passErrFormat(
	"%s%s",
	compileUnaryOp(u.op)
	compile(u.arg)
)

let (
	binaryOp    enum()
	binaryAnd   binaryOp()
	binaryOr    binaryOp()
	xor         binaryOp()
	andNot      binaryOp()
	lshift      binaryOp()
	rshift      binaryOp()
	mul         binaryOp()
	div         binaryOp()
	mod         binaryOp()
	add         binaryOp()
	sub         binaryOp()
	eq          binaryOp()
	notEq       binaryOp()
	less        binaryOp()
	lessOrEq    binaryOp()
	greater     binaryOp()
	greaterOrEq binaryOp()
	logicalAnd  binaryOp()
	logicalOr   binaryOp()
)

fn compileBinaryOp(o) {
	switch o {
	case binaryAnd:
		return "&"
	case binaryOr:
		return "|"
	case xor:
		return "^"
	case andNot:
		return "&^"
	case lshift:
		return "<<"
	case rshift:
		return ">>"
	case mul:
		return "*"
	case div:
		return "/"
	case mod:
		return "%"
	case add:
		return "+"
	case sub:
		return "-"
	case eq:
		return "=="
	case notEq:
		return "!="
	case less:
		return "<"
	case lessOrEq:
		return "<="
	case greater:
		return ">"
	case greaterOrEq:
		return ">="
	case logicalAnd:
		return "&&"
	case logicalOr:
		return "||"
	default:
		return error(formats("unsupported code: %v"), o)
	}
}

fn compileBinary(b) passErrFormat(
	"(%s %s %s)"
	compile(b.left)
	compileBinaryOp(b.op)
	compile(b.right)
)

fn compileTernary(c) passErrFormat(
	"func () interface{} { if %s { return %s } else { return %s } }()"
	compile(c.condition)
	compile(c.consequent)
	compile(c.alternative)
)

fn compileIf(c)
	has("alternative", c) ?
	passErrFormat(
		"if %s { %s } else { %s }"
		compile(c.condition)
		compile(c.consequent)
		compile(c.alternative)
	) :
	passErrFormat(
		"if %s { %s }"
		compile(c.condition)
		compile(c.consequent)
	)

fn compileSwitch(s)
	(has("expression", s) ? compile(s.expression) : "")
	-> fn (c) [c, map(compile, s.cases)]
	-> fn (c) (
		len(s.defaultStatements.statements) > 0 ?
		[
			c[0]
			[
				c[1]...
				s.defaultStatements
				-> compile
				-> passErr(formatOne("default:\n%s"))
			]
		] :
		c
	)
	-> fn (c) isError(c[0]) ? c[0] : isError(anyErr(c[1])) ? anyErr(c[1]) : c
	-> passErr(fn (c) [c[0], join("\n", c[1])])
	-> passErr(format("func() interface{} {\nswitch %s {\n%s\n} }()"))

fn compileSelect(s)
	s.cases
	-> map(compile)
	-> fn (c) (
		s.hasDefault ?
		[c..., s.defaultStatements -> compile -> passErr(formatOne("default:\n%s")) ] :
		c
	)
	-> anyErr
	-> passErr(join("\n"))
	-> passErr(formatOne("func() interface{} {\nselect {\n%s\n} }()"))

fn compileRangeOver(r) {
	switch {
	case !has("expression", r):
		return passErrFormat(
			"%s := 0; true; %s++"
			r.symbol
			r.symbol
		)
	case has("type", r.expression) &&
		r.expression.type == "range-expression":
		return passErrFormat(
			"%s := %s; %s; %s++"
			r.symbol
			has("from", r.expression) ? compile(r.expression.from) : "0"
			has("to", r.expression) ?
				formats("%s < %s", r.symbol, compile(r.expression.to)) :
				"true"
			r.symbol
		)
	default:
		return passErrFormat(
			"_, %s := range %s"
			r.symbol
			compile(r.expression)
		)
	}
}

fn compileLoop(l) passErrFormat(
	"for %s {\n%s\n}"
	has("expression", l) ? compile(l.expression) : ""
	compile(l.body)
)

let (
	controlStatement enum()
	breakControl     controlStatement()
	continueControl  controlStatement()
)

fn compile(code) {
	switch {
	case isInt(code):
		return compileInt(code)
	case isFloat(code):
		return compileFloat(code)
	case isString(code):
		return compileString(code)
	case isBool(code):
		return compileBool(code)
	}

	switch code.type {
	case "comment":
		return compileComment(code)
	case "symbol":
		return compileSymbol(code)
	case "module":
		return compileModule(code)
	case "list":
		return compileList(code)
	case "entry":
		return compileEntry(code)
	case "structure":
		return compileStructure(code)
	case "function":
		return compileFunction(code)
	case "range-expression":
		return compileRangeExpression(code)
	case "indexer":
		return compileIndexer(code)
	case "spread":
		return compileSpread(code)
	case "function-application":
		return compileApplication(code)
	case "unary":
		return compileUnary(code)
	case "binary":
		return compileBinary(code)
	case "cond":
		return compileCond(code)
	case "switch-case":
		return compileCase(code)
	case "switch-statement":
		return compileSwitch(code)
	case "send":
		return compileSend(code)
	case "receive":
		return compileReceive(code)
	case "go":
		return compileGo(code)
	case "defer":
		return compileDefer(code)
	case "select-case":
		return compileCase(code)
	case "select":
		return compileSelect(code)
	case "range-over":
		return compileRangeOver(code)
	case "loop":
		return compileLoop(code)
	case "definition":
		return compileDefinition(code)
	case "definition-list":
		return compileDefinitions(code)
	case "assign":
		return compileAssign(code)
	case "assign-list":
		return compileAssigns(code)
	case "ret":
		return compileRet(code)
	case "control-statement":
		return compileControl(code)
	case "statement-list":
		return compileStatements(code.statements)
	default:
		return error(formats("unsupported code: %v", code))
	}
}

let write stdout
write("package mml

func Compile() {
")

stdin
-> read
-> passErr(compile)
-> passErr(write)
-> onlyErr(log)

write("}")
