fn (
	fold(f, i, l)            len(l) == 0 ? i : fold(f, f(l[0], i), l[1:])
	foldr(f, i, l)           len(l) == 0 ? i : f(l[0], foldr(f, i, l[1:]))
	map(m, l)                fold(fn (c, r) [r..., m(c)], [], l)
	filter(p, l)             fold(fn (c, r) p(c) ? [r..., c] : r, [], l)
	not(x)                   !x
	yes(x)                   x
	ifErr(mod, f)            fn~ (a) mod(isError(a)) ? f(a) : a
	passErr(f)               ifErr(not, f)
	onlyErr(f)               ifErr(yes, f)
	anyErr(l)                fold(fn (c, r) isError(r) ? r : isError(c) ? c : [r..., c], [], l)
	firstOr(v, l)            len(l) > 0 ? l[0] : v
	join(j, s)               len(s) < 2 ? firstOr("", s) : s[0] + j + join(j, s[1:])
	joins(j, ...s)           join(j, s)
	joinTwo(j, left, right)  joins(j, left, right)
	destruct(s)              s -> keys -> map(fn (key) [key, s[key]])
	formats(f, ...a)         format(f, a)
	formatOne(f, a)          formats(f, a)
	passErrFormat(fmt, ...p) p -> anyErr -> passErr(format(fmt))
	notEmpty(l)              l -> filter(fn (s) s != "")
)

fn counter () {
	let ~ c -1
	return fn~ () {
		c = c + 1
		return c
	}
}

let enum counter

// TODO: should be a builtin fake function
fn~ log(...a) {
	a -> map(string) -> join(" ") -> stderr
	"\n" -> stderr
	return len(a) == 0 ? "" : a[len(a) - 1]
}

fn~ (
	readAll(input) input(-1)
	read(input)    input -> readAll -> passErr(parse)
)

fn escape(s) {
	if s == "" {
		return ""
	}

	let ~ first s[0]
	switch first {
	case "\b":
		first = "\\b"
	case "\f":
		first = "\\f"
	case "\n":
		first = "\\n"
	case "\r":
		first = "\\r"
	case "\t":
		first = "\\t"
	case "\v":
		first = "\\v"
	case "\"":
		first = "\\\""
	case "\\":
		first = "\\\\"
	}

	return first + escape(s[1:])
}

let (
	compileInt   string
	compileFloat string
	compileBool  string
)

fn getScope(...statements)
	statements
	-> filter(fn (s) has("type", s) && (s.type == "definition" || s.type == "definition-list"))
	-> fold(fn (d, flat) d.type == "definition" ? [flat..., d] : [flat..., d.definitions...], [])
	-> map(fn (d) d.symbol)

fn (
	mapCompile(l)         l -> map(compile) -> anyErr
	mapCompileJoin(j, l)  l -> mapCompile -> passErr(join(j))
	compileComment(_)     ""
	compileString(s)      formats("\"%s\"", escape(s))
	compileSymbol(s)      formats("_%s", s.name)
	compileEntry(e)       passErrFormat("\"%s\":%s", compile(e.key), compile(e.value))
	compileEntries(e)     mapCompileJoin(",", e)
	compileStructure(s)   passErrFormat("map[string]interface{}{%s}", compileEntries(s.entries))
	compileCond(c)        c.ternary ? compileTernary(c) : compileIf(c)
	compileSpread(s)      passErrFormat("%s.([]interface{})...", compile(s.value))
	compileCase(c)        passErrFormat("case %s:\n%s", compile(c.expression), compile(c.body))
	compileSend(s)        passErrFormat("%s <- %s", compile(s.channel), compile(s.value))
	compileReceive(r)     passErrFormat("<- %s", compile(r.channel))
	compileGo(g)          passErrFormat("go %s", compile(g.application))
	compileDefer(d)       passErrFormat("defer %s", compile(d.application))
	compileDefinitions(l) mapCompileJoin(";\n", l.definitions)
	compileAssign(a)      passErrFormat("%s = %s", compile(a.capture), compile(a.value))
	compileAssigns(l)     mapCompileJoin(";\n", l.assignments)
	compileRet(r)         passErrFormat("return %s", compile(r.value))
	compileControl(c)     c.control == breakControl ? "break" : "continue"
)

fn compileList(l) {
	let compileValues mapCompile

	fn (
		isSpread(c)     len(c) > 3 && c[len(c) - 3:] == "..."
		selectSpread(c) isSpread(c) ? {spread: c} : c
	)

	let groupSpread fold(fn (item, groups) {
		let (
			i             len(groups) - 1
			isSpread      has("spread", item)
			groupIsSpread i >= 0 && has("spread", groups[i])
		)

		fn (
			appendNewSimple() [groups..., {simple: [item]}]
			appendNewSpread() [groups..., {spread: [item.spread]}]
			appendSimple()    [groups[:i]..., {simple: [groups[i].simple..., item]}]
			appendSpread()    [groups[:i]..., {spread: [groups[i].spread..., item.spread]}]
		)

		switch {
		case (i < 0 || groupIsSpread) && !isSpread:
			return appendNewSimple()
		case (i < 0 || !groupIsSpread) && isSpread:
			return appendNewSpread()
		case !groupIsSpread && !isSpread:
			return appendSimple()
		case groupIsSpread && isSpread:
			return appendSpread()
		}
	}, [])

	fn (
		appendSimples(code, group) formats("append(%s, %s)", code, join(", ", group))
		appendSpread(item, code)   formats("append(%s, %s)", code, item)
		appendSpreads(code, group) fold(appendSpread, code, group)
		appendGroups(groups)       fold(appendGroup, "[]interface{}{}", groups)
	)

	fn appendGroup(group, code) has("spread", group) ?
		appendSpreads(code, group.spread) :
		appendSimples(code, group.simple)

	return l.values
	-> compileValues
	-> passErr(map(selectSpread))
	-> passErr(groupSpread)
	-> passErr(appendGroups)
}

fn compileParamList(params, collectParam) {
	let ~ p []
	for i in 0:len(params) {
		p = [p..., formats("var _%s = a[%d]", params[i], i)]
	}

	if collectParam != "" {
		p = [p..., formats("var _%s = a[%d:]", collectParam, len(params))]
	}

	return join(";\n", p)
}

fn compileFunction(f) {
	let multipleStatements
		has("type", f.statement) &&
		f.statement.type == "statement-list"
	let scope getScope(f.statement)
	let paramNames f.collectParam == "" ? f.params : [f.params..., f.collectParam]
	let scopeNames join(", ", map(formatOne("_%s"), [scope..., paramNames...]))
	let scopeDefs scope
		-> map(fn (s) formats("var _%s interface{}", s))
		-> join(";\n")

	let fmt multipleStatements ?
		"&cfunction{
			f: func(a []interface{}) interface{} {
				var c interface{}
				nop(c)
				%s;
				%s;
				nop(%s);
				%s;
				return nil
			},
			fixedArgs: %d,
		}" :
		"&cfunction{
			f: func(a []interface{}) interface{} {
				var c interface{}
				nop(c)
				%s;
				%s;
				nop(%s);
				return %s
			},
			fixedArgs: %d,
		}"

	let (
		p compileParamList(f.params, f.collectParam)
		s compile(f.statement)
	)

	if isError(s) {
		return s
	}

	return formats(fmt, p, scopeDefs, scopeNames, s, len(f.params))
}

fn compileRangeExpression(e) passErrFormat(
	"%s:%s"
	has("from", e) ? compile(e.from) : ""
	has("to", e) ? compile(e.to) : ""
)

fn compileIndexer(i) {
	let exp compile(i.expression)
	if isError(exp) {
		return exp
	}

	if !has("type", i.index) || i.index.type != "range-expression" {
		let index compile(i.index)
		if isError(index) {
			return index
		}

		return formats("ref(%s, %s)", exp, index)
	}

	let ~ from "nil"
	if has("from", i.index) {
		from = compile(i.index.from)
		if isError(from) {
			return from
		}
	}

	let ~ to "nil"
	if has("to", i.index) {
		to = compile(i.index.to)
		if isError(to) {
			return to
		}
	}

	return formats("refRange(%s, %s, %s)", exp, from, to)
}

fn compileApplication(a) passErrFormat(
	has("type", a.function) && a.function.type == "function" ? "(%s).call(%s)" : "%s.(*cfunction).call(%s)"
	compile(a.function)
	compileList({values: a.args})
)

let (
	unaryOp    enum()
	binaryNot  unaryOp()
	plus       unaryOp()
	minus      unaryOp()
	logicalNot unaryOp()
)

fn compileUnary(u) {
	let arg compile(u.arg)
	if isError(arg) {
		return arg
	}

	switch u.op {
	case logicalNot:
		if !isBool(u.arg) {
			arg = arg + ".(bool)"
		}

		return formats("!%s", arg)
	default:
		return formats("unaryOp(%d, %s)", u.op, arg)
	}
}

let (
	binaryOp    enum()
	binaryAnd   binaryOp()
	binaryOr    binaryOp()
	xor         binaryOp()
	andNot      binaryOp()
	lshift      binaryOp()
	rshift      binaryOp()
	mul         binaryOp()
	div         binaryOp()
	mod         binaryOp()
	add         binaryOp()
	sub         binaryOp()
	eq          binaryOp()
	notEq       binaryOp()
	less        binaryOp()
	lessOrEq    binaryOp()
	greater     binaryOp()
	greaterOrEq binaryOp()
	logicalAnd  binaryOp()
	logicalOr   binaryOp()
)

fn compileBinary(b) {
	if b.op != logicalAnd && b.op != logicalOr {
		return passErrFormat(
			"binaryOp(%s, %s, %s)"
			compile(b.op)
			compile(b.left)
			compile(b.right)
		)
	}

	fn isBoolOp(c)
		has("type", c) &&
		(c.type == "unary" && c.op == logicalNot) ||
		(c.type == "binary" && (c.op == logicalAnd || c.op == logicalOr))

	let ~ left compile(b.left)
	if isError(left) {
		return left
	}

	let ~ right compile(b.right)
	if isError(right) {
		return right
	}

	if !isBool(b.left) && !isBoolOp(b.left) {
		left = left + ".(bool)"
	}

	if !isBool(b.right) && !isBoolOp(b.right) {
		right = right + ".(bool)"
	}

	let ~ op "&&"
	if b.op == logicalOr {
		op = "||"
	}

	return formats("(%s %s %s)", left, op, right)
}

fn compileTernary(c) passErrFormat(
	"func () interface{} { c = %s; if c.(bool) { return %s } else { return %s } }()"
	compile(c.condition)
	compile(c.consequent)
	compile(c.alternative)
)

fn compileIf(c)
	has("alternative", c) ?
	passErrFormat(
		"c = %s; if c.(bool) { %s } else { %s }"
		compile(c.condition)
		compile(c.consequent)
		compile(c.alternative)
	) :
	passErrFormat(
		"c = %s; if c.(bool) { %s }"
		compile(c.condition)
		compile(c.consequent)
	)

fn compileSwitch(s) {
	let (
		hasDefault len(s.defaultStatements.statements) > 0
		exp has("expression", s) ? compile(s.expression) : ""
	)

	if isError(exp) {
		return exp
	}

	let cases s.cases -> map(compile) -> anyErr
	if isError(cases) {
		return cases
	}

	let def hasDefault ? compile(s.defaultStatements) : ""
	if isError(def) {
		return def
	}

	let (
		defaultCode hasDefault ? formats("default:\n%s", def) : ""
		casesCode join("\n", hasDefault ? [cases..., defaultCode] : cases)
	)

	return formats("switch %s {\n%s\n}", exp, casesCode)
}

fn compileSelect(s)
	s.cases
	-> map(compile)
	-> fn (c) (
		s.hasDefault ?
		[c..., s.defaultStatements -> compile -> passErr(formatOne("default:\n%s")) ] :
		c
	)
	-> anyErr
	-> passErr(join("\n"))
	-> passErr(formatOne("func() interface{} {\nselect {\n%s\n} }()"))

fn compileRangeOver(r) {
	fn infiniteCounter() passErrFormat(
		"_%s := 0; true; _%s++"
		r.symbol
		r.symbol
	)

	fn withRangeExpression() passErrFormat(
		"_%s := %s; %s; _%s++"
		r.symbol
		has("from", r.expression) ? compile(r.expression.from) : "0"
		has("to", r.expression) ?
			formats("_%s < %s.(int)", r.symbol, compile(r.expression.to)) :
			"true"
		r.symbol
	)

	fn listStyleRange() passErrFormat(
		"_, _%s := range %s"
		r.symbol
		compile(r.expression)
	)

	switch {
	case !has("expression", r):
		return infiniteCounter()
	case has("type", r.expression) && r.expression.type == "range-expression":
		return withRangeExpression()
	default:
		return listStyleRange()
	}
}

fn compileLoop(l) passErrFormat(
	"for %s {\n%s\n}"
	has("expression", l) ? compile(l.expression) : ""
	compile(l.body)
)

fn compileDefinition(d) passErrFormat(
	"_%s = %s"
	d.symbol
	compile(d.expression)
)

let (
	controlStatement enum()
	breakControl     controlStatement()
	continueControl  controlStatement()
)

fn compileStatements(s) {
	let scope getScope(s...)
	let scopeDefs scope
		-> map(fn (s) formats("var _%s interface{}", s))
		-> join(";\n")
	let scopeNames join(", ", map(formatOne("_%s"), scope))
	let statements mapCompile(s) -> passErr(notEmpty) -> passErr(join(";\n"))
	return formats("%s;\nnop(%s);\n%s", scopeDefs, scopeNames, statements)
}

fn compileModule(m) {
	let statements compileStatements(m.statements)
	if isError(statements) {
		return statements
	}

	return formats("%s", statements)
}

fn compile(code) {
	switch {
	case isInt(code):
		return compileInt(code)
	case isFloat(code):
		return compileFloat(code)
	case isString(code):
		return compileString(code)
	case isBool(code):
		return compileBool(code)
	}

	switch code.type {
	case "comment":
		return compileComment(code)
	case "symbol":
		return compileSymbol(code)
	case "module":
		return compileModule(code)
	case "list":
		return compileList(code)
	case "entry":
		return compileEntry(code)
	case "structure":
		return compileStructure(code)
	case "function":
		return compileFunction(code)
	case "range-expression":
		return compileRangeExpression(code)
	case "indexer":
		return compileIndexer(code)
	case "spread":
		return compileSpread(code)
	case "function-application":
		return compileApplication(code)
	case "unary":
		return compileUnary(code)
	case "binary":
		return compileBinary(code)
	case "cond":
		return compileCond(code)
	case "switch-case":
		return compileCase(code)
	case "switch-statement":
		return compileSwitch(code)
	case "send":
		return compileSend(code)
	case "receive":
		return compileReceive(code)
	case "go":
		return compileGo(code)
	case "defer":
		return compileDefer(code)
	case "select-case":
		return compileCase(code)
	case "select":
		return compileSelect(code)
	case "range-over":
		return compileRangeOver(code)
	case "loop":
		return compileLoop(code)
	case "definition":
		return compileDefinition(code)
	case "definition-list":
		return compileDefinitions(code)
	case "assign":
		return compileAssign(code)
	case "assign-list":
		return compileAssigns(code)
	case "ret":
		return compileRet(code)
	case "control-statement":
		return compileControl(code)
	case "statement-list":
		return compileStatements(code.statements)
	default:
		return error(formats("unsupported code: %v", code))
	}
}

let write stdout
write("package mml

import \"fmt\"
import \"os\"
import \"errors\"

type cfunction struct {
	f         func([]interface{}) interface{}
	fixedArgs int
	args      []interface{}
}

func (f *cfunction) bind(a []interface{}) *cfunction {
	b := *f
	b.args = a
	return &b
}

func (f *cfunction) call(a []interface{}) interface{} {
	a = append(f.args, a...)
	if len(a) < f.fixedArgs {
		return f.bind(a)
	}

	return f.f(a)
}

func ref(v, k interface{}) interface{} {
	switch vt := v.(type) {
	case []interface{}:
		return vt[k.(int)]
	case map[string]interface{}:
		return vt[k.(string)]
	default:
		panic(\"ref: unsupported code\")
	}
}

func refRange(v, from, to interface{}) interface{} {
	switch {
	case from == nil && to == nil:
		return v.([]interface{})[:]
	case from == nil:
		return v.([]interface{})[:to.(int)]
	case to == nil:
		return v.([]interface{})[from.(int):]
	default:
		return v.([]interface{})[from.(int):to.(int)]
	}
}

func unaryOp(op int, arg interface{}) interface{} {
	switch op {
	case 0:
		switch at := arg.(type) {
		case int:
			return +at
		default:
			panic(\"unary: unsupported code\")
		}
	case 1:
		switch at := arg.(type) {
		case int:
			return +at
		case float64:
			return +at
		default:
			panic(\"unary: unsupported code\")
		}
	case 2:
		switch at := arg.(type) {
		case int:
			return -at
		case float64:
			return -at
		default:
			panic(\"unary: unsupported code\")
		}
	default:
		panic(\"unary: unsupported code\")
	}
}

func binaryOp(op int, left, right interface{}) interface{} {
	switch op {
	case 0:
		switch lt := left.(type) {
		case int:
			return lt & right.(int)
		default:
			panic(\"binary: unsupported code\")
		}
	case 1:
		switch lt := left.(type) {
		case int:
			return lt | right.(int)
		default:
			panic(\"binary: unsupported code\")
		}
	case 2:
		switch lt := left.(type) {
		case int:
			return lt ^ right.(int)
		default:
			panic(\"binary: unsupported code\")
		}
	case 3:
		switch lt := left.(type) {
		case int:
			return lt &^ right.(int)
		default:
			panic(\"binary: unsupported code\")
		}
	case 4:
		switch lt := left.(type) {
		case int:
			return lt << right.(uint)
		default:
			panic(\"binary: unsupported code\")
		}
	case 5:
		switch lt := left.(type) {
		case int:
			return lt >> right.(uint)
		default:
			panic(\"binary: unsupported code\")
		}
	case 6:
		switch lt := left.(type) {
		case int:
			return lt * right.(int)
		case float64:
			return lt * right.(float64)
		default:
			panic(\"binary: unsupported code\")
		}
	case 7:
		switch lt := left.(type) {
		case int:
			return lt / right.(int)
		case float64:
			return lt / right.(float64)
		default:
			panic(\"binary: unsupported code\")
		}
	case 8:
		switch lt := left.(type) {
		case int:
			return lt % right.(int)
		default:
			panic(\"binary: unsupported code\")
		}
	case 9:
		switch lt := left.(type) {
		case int:
			return lt + right.(int)
		case float64:
			return lt + right.(float64)
		case string:
			return lt + right.(string)
		default:
			panic(\"binary: unsupported code\")
		}
	case 10:
		switch lt := left.(type) {
		case int:
			return lt - right.(int)
		case float64:
			return lt - right.(float64)
		default:
			panic(\"binary: unsupported code\")
		}
	case 11:
		return left == right
	case 12:
		return left != right
	case 13:
		switch lt := left.(type) {
		case int:
			return lt < right.(int)
		case float64:
			return lt < right.(float64)
		case string:
			return lt < right.(string)
		default:
			panic(\"binary: unsupported code\")
		}
	case 14:
		switch lt := left.(type) {
		case int:
			return lt <= right.(int)
		case float64:
			return lt <= right.(float64)
		case string:
			return lt <= right.(string)
		default:
			panic(\"binary: unsupported code\")
		}
	case 15:
		switch lt := left.(type) {
		case int:
			return lt > right.(int)
		case float64:
			return lt > right.(float64)
		case string:
			return lt > right.(string)
		default:
			panic(\"binary: unsupported code\")
		}
	case 16:
		switch lt := left.(type) {
		case int:
			return lt <= right.(int)
		case float64:
			return lt <= right.(float64)
		case string:
			return lt <= right.(string)
		default:
			panic(\"binary: unsupported code\")
		}
	default:
		panic(\"binary: unsupported code\")
	}
}

func nop(...interface{}) {}

var _len interface{} = &cfunction{
	f: func(a []interface{}) interface{} {
		switch at := a[0].(type) {
		case []interface{}:
			return len(at)
		case map[string]interface{}:
			return len(at)
		case string:
			return len(at)
		default:
			panic(\"len: unsupported code\")
		}
	},
	fixedArgs: 1,
}

var _isError interface{} = &cfunction{
	f: func(a []interface{}) interface{} {
		_, ok := a[0].(error)
		return ok
	},
	fixedArgs: 1,
}

var _keys interface{} = &cfunction{
	f: func(a []interface{}) interface{} {
		s, ok := a[0].(map[string]interface{})
		if !ok {
			panic(\"keys: unsupported code\")
		}

		var keys []interface{}
		for k := range s {
			keys = append(keys, k)
		}

		return keys
	},
	fixedArgs: 1,
}

var _format interface{} = &cfunction{
	f: func(a []interface{}) interface{} {
		f, ok := a[0].(string)
		if !ok {
			panic(\"format: unsupported code\")
		}

		args, ok := a[1].([]interface{})
		if !ok {
			panic(\"format: unsupported code\")
		}

		return fmt.Sprintf(f, args...)
	},
	fixedArgs: 2,
}

var _stderr interface{} = &cfunction{
	f: func(a []interface{}) interface{} {
		s, ok := a[0].(string)
		if !ok {
			panic(\"stderr: unsupported code\")
		}

		_, err := os.Stderr.Write([]byte(s))
		return err
	},
	fixedArgs: 1,
}

var _stdout interface{} = &cfunction{
	f: func(a []interface{}) interface{} {
		s, ok := a[0].(string)
		if !ok {
			panic(\"stderr: unsupported code\")
		}

		_, err := os.Stdout.Write([]byte(s))
		return err
	},
	fixedArgs: 1,
}

var _stdin interface{} = &cfunction{
	f: func(a []interface{}) interface{} {
		b := make([]byte, a[0].(int))
		n, err := os.Stdin.Read(b)
		if err != nil {
			return err
		}

		return string(b[:n])
	},
	fixedArgs: 1,
}

var _string interface{} = &cfunction{
	f: func(a []interface{}) interface{} {
		return fmt.Sprint(a[0])
	},
	fixedArgs: 1,
}

var _parse interface{} = &cfunction{
	f: func(a []interface{}) interface{} {
		return 42
	},
	fixedArgs: 1,
}

var _has interface{} = &cfunction{
	f: func(a []interface{}) interface{} {
		s, ok := a[1].(map[string]interface{})
		if !ok {
			return false
		}

		_, ok = s[a[0].(string)]
		return ok
	},
	fixedArgs: 2,
}

var _isBool interface{} = &cfunction{
	f: func(a []interface{}) interface{} {
		_, ok := a[0].(bool)
		return ok
	},
	fixedArgs: 1,
}

var _isInt interface{} = &cfunction{
	f: func(a []interface{}) interface{} {
		_, ok := a[0].(int)
		return ok
	},
	fixedArgs: 1,
}

var _isFloat interface{} = &cfunction{
	f: func(a []interface{}) interface{} {
		_, ok := a[0].(float64)
		return ok
	},
	fixedArgs: 1,
}

var _isString interface{} = &cfunction{
	f: func(a []interface{}) interface{} {
		_, ok := a[0].(string)
		return ok
	},
	fixedArgs: 1,
}

var _error interface{} = &cfunction{
	f: func(a []interface{}) interface{} {
		return errors.New(a[0].(string))
	},
	fixedArgs: 1,
}

func init() {
var c interface{}
nop(c)
")

stdin
-> read
-> passErr(compile)
-> passErr(write)
-> onlyErr(log)

write("}")
