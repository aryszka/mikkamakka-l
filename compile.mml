use (
	. "lang"
	  "strings"
	  "code"
	  "lists"
	  "structs"
	  "snippets"
	  "codetree"
)

fn context() {
	scope: {definitions: {}}
}

fn extend(ctx) {
	ctx...
	scope: {
		parent:      ctx.scope
		definitions: {}
	}
}

fn inParentScope(name, ctx) {
	fn defined(scope)
		has("parent", scope) && (
			has(name, scope.parent.definitions) ||
			defined(scope.parent)
		)
	return defined(ctx.scope)
}

fn define(name, ctx) {
	ctx.scope.definitions[name] = true
	return ctx
}

fn primitive(_, code) string(code.value)

let (
	intLiteral   primitive
	floatLiteral primitive
	boolLiteral  primitive
)

fn stringLiteral(ctx, s) formats("\"%s\"", strings.escape(s.value))

fn symbol(ctx, s) formats("_%s", s.name)

fn spread(ctx, s) formats("%s.(*mml.List).Values...", do(ctx, s.value))

fn list(ctx, l) {
	fn (
		isSpread(c)     len(c) > 3 && c[len(c) - 3:] == "..."
		selectSpread(c) isSpread(c) ? {spread: c} : c
	)

	let groupSpread fold(fn (item, groups) {
		let (
			i             len(groups) - 1
			isSpread      has("spread", item)
			groupIsSpread i >= 0 && has("spread", groups[i])
		)

		fn (
			appendNewSimple() [groups..., {simple: [item]}]
			appendNewSpread() [groups..., {spread: [item.spread]}]
			appendSimple()    [groups[:i]..., {simple: [groups[i].simple..., item]}]
			appendSpread()    [groups[:i]..., {spread: [groups[i].spread..., item.spread]}]
		)

		switch {
		case (i < 0 || groupIsSpread) && !isSpread:
			return appendNewSimple()
		case (i < 0 || !groupIsSpread) && isSpread:
			return appendNewSpread()
		case !groupIsSpread && !isSpread:
			return appendSimple()
		case groupIsSpread && isSpread:
			return appendSpread()
		}
	}, [])

	fn (
		appendSimples(code, group) formats("append(%s, %s)", code, join(", ", group))
		appendSpread(item, code)   formats("append(%s, %s)", code, item)
		appendSpreads(code, group) fold(appendSpread, code, group)
		appendGroups(groups)       fold(appendGroup, "[]interface{}{}", groups)
	)

	fn appendGroup(group, code) has("spread", group) ?
		appendSpreads(code, group.spread) :
		appendSimples(code, group.simple)

	return l.values
		-> map(do(ctx))
		-> map(selectSpread)
		-> groupSpread
		-> appendGroups
		-> fn (c) formats("&mml.List{Values: %s}", c)
}

fn expressionKey(ctx, k) do(ctx, k.value)

fn struct(ctx, s) {
	fn entry(e) {
		let v do(ctx, e.value)
		switch e.type {
		case "spread":
			let (
				var    formats("sp := %s.(*mml.Struct);", v)
				assign "for k, v := range sp.Values { s.Values[k] = v };"
			)

			return formats("func() { %s; %s }();\n", var, assign)
		default:
			switch e.key.type {
			case "string":
				return formats("s.Values[%s] = %s;", do(ctx, e.key), v)
			case "symbol":
				return formats("s.Values[\"%s\"] = %s;", e.key.name, v)
			default:
				return formats("s.Values[%s.(string)] = %s;", do(ctx, e.key), v)
			}
		}
	}

	return formats(
		"func() interface{} { s := &mml.Struct{Values: make(map[string]interface{})}; %s; return s }()"
		s.entries -> map(entry) -> join("")
	)
}

fn getDefinitions(statementList) {
	let definitions = statementList.statements
		-> filter(is({type: "definition"}))

	let definitionsFromGroups = statementList.statements
		-> filter(is({type: "definition-group"}))
		-> map(structs.get("definitions"))
		-> flat
	
	return [
		definitions...
		definitionsFromGroups...
	]
}

fn getScope(statementList) {
	let definitions = statementList -> getDefinitions -> map(structs.get("symbol"))
	
	let uses = statementList.statements
		-> filter(is({type: "use-list"}))
		-> map(structs.get("uses"))
		-> flat
	
	let (
		unnamedUses = uses -> filter(is(not({capture: any}))) -> map(structs.get("path")) -> map(structs.get("value"))
		namedUses   = uses -> filter(is({capture: not(".")})) -> map(structs.get("capture"))
	)

	let inlineUses = uses
		-> filter(is({capture: "."}))
		-> map(structs.get("module"))
		-> map(structs.get("body"))
		-> map(getDefinitions)
		-> flat
		-> filter(is({exported: true}))
		-> map(structs.get("symbol"))
	
	return flats(
		definitions
		unnamedUses
		namedUses
		inlineUses
	)
}

fn paramList(params, collectParam) {
	let (
		paramFormat        = "var _%s = a[%d]"
		collectParamFormat = "var _%s interface{}; _%s = &mml.List{a[%d:]}"
		paramsString       = params -> lists.indexes -> map(fn (i) formats(paramFormat, params[i], i))
		collectParamString = formats(collectParamFormat, collectParam, collectParam, len(params))
	)

	return join(";\n", [paramsString..., collectParamString])
}

fn functionLiteral(ctx, f) {
	let paramNames f.collectParam == "" ? f.params : [f.params..., f.collectParam]

	let statementListFormat = "&mml.Function{
		F: func(a []interface{}) interface{} {
			var c interface{}
			var f *mml.Function
			mml.Nop(c, f)
			%s;
			mml.Nop(%s);
			%s;
			return nil
		},
		FixedArgs: %d,
	}"

	let expressionFormat = "&mml.Function{
		F: func(a []interface{}) interface{} {
			var c interface{}
			var f *mml.Function
			mml.Nop(c, f)
			%s;
			mml.Nop(%s);
			return %s
		},
		FixedArgs: %d,
	}"

	let c extend(ctx)
	for p in paramNames {
		define(p, c)
	}

	return formats(
		is({type: "statement-list"}, f.body) ? statementListFormat : expressionFormat
		paramList(f.params, f.collectParam)
		join(", ", map(strings.formatOne("_%s"), [paramNames...]))
		do(c, f.body)
		len(f.params)
	)
}

fn symbolIndex(ctx, i) formats("\"%s\"", i.symbol)

fn indexer(ctx, i) {
	switch {
	case is({type: "range"}, i.index):
		return formats(
			"mml.RefRange(%s, %s, %s)"
			do(ctx, i.expression)
			is({from: any}, i.index) ? do(ctx, i.index.from) : "nil"
			is({to: any}, i.index) ? do(ctx, i.index.to) : "nil"
		)
	default:
		return formats(
			"mml.Ref(%s, %s)"
			do(ctx, i.expression)
			do(ctx, i.index)
		)
	}
}

fn application(ctx, a) formats(
	is({function: {type: "function"}}, a) ?
		"(%s).Call((%s).Values)" :
		"%s.(*mml.Function).Call((%s).Values)"
	do(ctx, a.function)
	list(ctx, {values: a.args})
)

fn unary(ctx, u)
	u.op == code.logicalNot ?
	formats(is({type: "bool"}, u.arg) ? "!%s" : "!%s.(bool)", do(ctx, u.arg)) :
	formats("mml.UnaryOp(%d, %s)", u.op, do(ctx, u.arg))

fn binary(ctx, b) {
	if !is(or(code.logicalAnd, code.logicalOr), b.op) {
		return formats(
			"mml.BinaryOp(%d, %s, %s)"
			b.op
			do(ctx, b.left)
			do(ctx, b.right)
		)
	}

	fn isBoolOp(c) is({
		type: or("unary", "binary")
		op:   or(code.logicalNot, code.logicalAnd, code.logicalOr)
	}, c)

	fn (
		isBoolValue(c)         is({type: "bool"}, c)
		convertIfNotBool(c, s) isBoolValue(c) || isBoolOp(c) ? s : s + ".(bool)"
	)

	let (
		left  = b.left -> do(ctx) -> convertIfNotBool(b.left)
		right = b.right -> do(ctx) -> convertIfNotBool(b.right)
		op    = b.op == code.logicalAnd ? "&&" : "||"
	)

	return formats("(%s %s %s)", left, op, right)
}

fn ternary(ctx, c) formats(
	"func () interface{} { c = %s; if c.(bool) { return %s } else { return %s } }()"
	do(ctx, c.condition)
	do(ctx, c.consequent)
	do(ctx, c.alternative)
)

fn ifStatement(ctx, c) {
	let (
		ct extend(ctx)
		cn do(ct, c.condition)
		cq do(ct, c.consequent)
		ia is({alternative: any}, c)
		at ia ? do(ct, c.alternative) : ""
		ft ia ? "c = %s; if c.(bool) { %s } else { %s }" : "c = %s; if c.(bool) { %s }"
	)

	return ia ? formats(ft, cn, cq, at) : formats(ft, cn, cq)
}

fn cond(ctx, c) c.ternary ? ternary(ctx, c) : ifStatement(ctx, c)

// TODO:
// - test receive definition
// - test receive definition shadowing
fn caseBlock(ctx, c) {
	let (
		ct extend(ctx)
		e  do(ct, c.expression)
		b  do(ct, c.body)
	)

	return formats("case %s:\n%s", e, b)
}

fn switchStatement(ctx, s) {
	let (
		hasDefault  len(s.defaultStatements.statements) > 0
		cases       s.cases -> map(do(ctx))
		def         hasDefault ? do(ctx, s.defaultStatements) : ""
		defaultCode hasDefault ? formats("default:\n%s", def) : ""
	)

	return formats(
		"switch %s {\n%s\n}"
		is({expression: any}, s) ? do(ctx, s.expression) : ""
		(hasDefault ? [cases..., defaultCode] : cases) -> join("\n")
	)
}

fn sendStatement(ctx, s) formats("%s <- %s", do(ctx, s.channel), do(ctx, s.value))

fn receiveExpression(ctx, r) formats("<-%s", do(ctx, r.channel))

fn goStatement(ctx, g) formats("go %s", do(ctx, g.application))

fn deferStatement(ctx, d) formats(
	is({application: {function: {type: "function"}}}, d) ?
		"f = (%s); defer f.Call((%s).Values)" :
		"defer %s.(*mml.Function).Call((%s).Values)"
	do(ctx, d.application.function)
	list(ctx, {values: d.application.args})
)

fn selectStatement(ctx, s)
	s.cases
	-> map(do(ctx))
	-> fn (c) (
		s.hasDefault ?
		[
			c...
			s.defaultStatements
				-> do(ctx)
				-> strings.formatOne("default:\n%s")
		] :
		c
	)
	-> join("\n")
	-> strings.formatOne("func() interface{} {\nselect {\n%s\n} }()")

fn rangeOver(ctx, r) {
	fn infiniteCounter() formats(
		"_%s := 0; true; _%s++"
		r.symbol
		r.symbol
	)

	fn withRangeExpression() formats(
		"_%s := %s; %s; _%s++"
		r.symbol
		has("from", r.expression) ? is({type: "int"}, r.expression.from) ? do(ctx, r.expression.from) : do(ctx, r.expression.from) + ".(int)" : "0"
		has("to", r.expression) ?
			formats("_%s < %s.(int)", r.symbol, do(ctx, r.expression.to)) :
			"true"
		r.symbol
	)

	// TODO:
	// - should work for struct, too
	// - the arg should be called with nop() (only if not checking in advance?)
	fn listStyleRange() formats(
		"_, _%s := range %s.(*mml.List).Values"
		r.symbol
		do(ctx, r.expression)
	)

	switch {
	case !has("expression", r):
		return infiniteCounter()
	case is({type: "range"}, r.expression):
		return withRangeExpression()
	default:
		return listStyleRange()
	}
}

fn (
	breakStatement(_, __)    "break"
	continueStatement(_, __) "continue"
)

fn loop(ctx, l) {
	let (
		c extend(ctx)
		e has("expression", l) ? do(c, l.expression) : ""
		b do(c, l.body)
	)

	return formats("for %s {\n%s\n}", e, b)
}

fn definition(ctx, d)
	d.exported ?
	formats(
		"_%s = %s; exports[\"%s\"] = _%s"
		d.symbol
		do(define(d.symbol, ctx), d.expression)
		d.symbol
		d.symbol
	) :
	formats(
		"_%s = %s"
		d.symbol
		do(define(d.symbol, ctx), d.expression)
	)

fn definitionGroup(ctx, g) g.definitions -> map(do(ctx)) -> join(";\n")

fn assign(ctx, a)
	a.capture.type == "symbol" ?
	formats(
		"func() interface{} { %s = %s; return nil }()"
		do(ctx, a.capture)
		do(ctx, a.value)
	) :
	formats(
		"mml.SetRef(%s, %s, %s)"
		do(ctx, a.capture.expression)
		do(ctx, a.capture.index)
		do(ctx, a.value)
	)

fn ret(ctx, r) has("value", r) ?
	formats("return %s", do(ctx, r.value)) :
	"return nil"

fn checkRet(ctx, r) formats(
	"if v := %s; mml.IsError.F([]interface{}{v}).(bool) { return v }"
	do(ctx, r.value)
)

fn useStatement(ctx, u) {
	switch {
	case is({capture: "."}, u):
		let statement formats(
			"var __%s = mml.Modules.Use(\"%s\");"
			code.getModuleName(u.path.value)
			u.path.value
		)

		let names = u.module.body
			-> getDefinitions
			-> filter(is({exported: true}))
			-> map(structs.get("symbol"))

		for name in names {
			define(name, ctx)
		}

		let assigns map(fn (name)
			formats(
				"_%s = __%s.Values[\"%s\"]"
				name
				code.getModuleName(u.path.value)
				name
			)
			names
		)
		-> join(";\n")

		return joins(";", statement, assigns)
	case is({capture: any}, u):
		define(u.capture, ctx)
		return formats(
			"_%s = mml.Modules.Use(\"%s\")"
			u.capture
			u.path.value
		)
	default:
		define(u.path.value, ctx)
		return formats(
			"_%s = mml.Modules.Use(\"%s\")"
			code.getModuleName(u.path.value)
			u.path.value
		)
	}
}

fn useList(ctx, u) u.uses -> map(do(ctx)) -> join(";\n")

fn module(ctx, m) joins(
	"\n"
	formats("modulePath = \"%s\"", m.path)
	snippets.moduleHead
	do(extend(ctx), m.body)
	snippets.moduleFooter
)

fn statementList(ctx, l) {
	let (
		scope      getScope(l)
		scopeNames scope -> map(bind(formats, "_%s")) -> join(", ")
		statements l.statements -> map(do(ctx)) -> join(";\n")
	)

	let scopeDefs = scope
		-> map(
			fn (name)
				inParentScope(name, ctx) ?
				formats("var _%s interface{} = _%s", name, name) :
				formats("var _%s interface{}", name)
		)
		-> join(";\n")

	return formats(
		"%s;\nmml.Nop(%s);\n%s"
		scopeDefs
		scopeNames
		statements
	)
}

fn do(ctx, code) {
	switch {
	case code.type == "int":
		return intLiteral(ctx, code)
	case code.type == "float":
		return floatLiteral(ctx, code)
	case code.type == "string":
		return stringLiteral(ctx, code)
	case code.type == "bool":
		return boolLiteral(ctx, code)
	}

	switch code.type {
	case "comment":
		return ""
	case "line-comment":
		return ""
	case "symbol":
		return symbol(ctx, code)
	case "list":
		return list(ctx, code)
	case "expression-key":
		return expressionKey(ctx, code)
	case "struct":
		return struct(ctx, code)
	case "function":
		return functionLiteral(ctx, code)
	case "symbol-index":
		return symbolIndex(ctx, code)
	case "indexer":
		return indexer(ctx, code)
	case "spread":
		return spread(ctx, code)
	case "application":
		return application(ctx, code)
	case "unary":
		return unary(ctx, code)
	case "binary":
		return binary(ctx, code)
	case "cond":
		return cond(ctx, code)
	case "switch-case":
		return caseBlock(ctx, code)
	case "switch-statement":
		return switchStatement(ctx, code)
	case "send-statement":
		return sendStatement(ctx, code)
	case "receive-expression":
		return receiveExpression(ctx, code)
	case "go-statement":
		return goStatement(ctx, code)
	case "defer-statement":
		return deferStatement(ctx, code)
	case "select-case":
		return caseBlock(ctx, code)
	case "select-statement":
		return selectStatement(ctx, code)
	case "range-over":
		return rangeOver(ctx, code)
	case "break":
		return breakStatement(ctx, code)
	case "continue":
		return continueStatement(ctx, code)
	case "loop":
		return loop(ctx, code)
	case "definition":
		return definition(ctx, code)
	case "definition-group":
		return definitionGroup(ctx, code)
	case "assign":
		return assign(ctx, code)
	case "ret":
		return ret(ctx, code)
	case "check-ret":
		return checkRet(ctx, code)
	case "use":
		return useStatement(ctx, code)
	case "use-list":
		return useList(ctx, code)
	case "module":
		return module(ctx, code)
	case "statement-list":
		return statementList(ctx, code)
	default:
		log("unexpected code:", code.type, code)
		return ""
	}
}

fn allModules(module) module
	-> codetree.filter(is({type: "use"}))
	-> map(structs.get("module"))
	-> map(allModules)
	-> flat
	-> bind(concats, [module])
	-> uniq(eq)

export fn toGo(module) joins(
	""
	snippets.head
	code.builtin
		-> keys
		-> sort(fn (left, right) left < right)
		-> map(fn (k) formats("var _%s interface{} = mml.%s", k, code.builtin[k]))
		-> join(";\n")
	snippets.initHead
	module
		-> allModules
		-> map(do(code.builtin -> keys -> fold(define, context())))
		-> join("\n")
	snippets.initFooter
	snippets.mainHead
	module.path
	snippets.mainFooter
)
