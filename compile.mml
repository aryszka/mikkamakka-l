use (
	. "lang"
	  "errors"
	  "code"
	  "strings"
)

fn notEmpty(l) l -> filter(fn (s) s != "")

let (
	compileInt   string
	compileFloat string
	compileBool  string
)

fn getScope(...statements) {
	let (
		defs code.flattenedStatements("definition", "definition-list", "definitions", statements)
		uses code.flattenedStatements("use", "use-list", "uses", statements)
	)

	let inlineUses uses
	-> filter(fn (u) u.capture == ".")
	-> filter(has("exportNames"))
	-> map(fn (u) u.exportNames)
	-> fold(fn (current, result) [result..., current...], [])

	let namedUses uses
	-> filter(fn (u) u.capture != "." && u.capture != "")

	let unnamedUses uses
	-> filter(fn (u) u.capture == "")

	return flat([
		map(fn (d) d.symbol, defs)
		map(fn (u) u.capture, namedUses)
		map(fn (u) u.path, unnamedUses)
		inlineUses
	])
}

fn (
	compileComment(_)     ""
	compileString(s)      formats("\"%s\"", strings.escape(s))
	compileSymbol(s)      formats("_%s", s.name)
	compileCond(c)        c.ternary ? compileTernary(c) : compileIf(c)
	compileSpread(s)      formats("%s.([]interface{})...", compile(s.value))
	compileCase(c)        formats("case %s:\n%s", compile(c.expression), compile(c.body))
	compileSend(s)        formats("%s <- %s", compile(s.channel), compile(s.value))
	compileReceive(r)     formats("<- %s", compile(r.channel))
	compileGo(g)          formats("go %s", compile(g.application))
	compileDefer(d)       formats("defer %s", compile(d.application))
	compileDefinitions(l) l.definitions -> map(compile) -> join(";\n")
	compileAssigns(l)     l.assignments -> map(compile) -> join(";\n")
	compileRet(r)         formats("return %s", compile(r.value))
	compileControl(c)     c.control == code.breakControl ? "break" : "continue"
	compileUseList(u)     u.uses -> map(compile) -> join(";\n")
)

fn compileList(l) {
	fn (
		isSpread(c)     len(c) > 3 && c[len(c) - 3:] == "..."
		selectSpread(c) isSpread(c) ? {spread: c} : c
	)

	let groupSpread fold(fn (item, groups) {
		let (
			i             len(groups) - 1
			isSpread      has("spread", item)
			groupIsSpread i >= 0 && has("spread", groups[i])
		)

		fn (
			appendNewSimple() [groups..., {simple: [item]}]
			appendNewSpread() [groups..., {spread: [item.spread]}]
			appendSimple()    [groups[:i]..., {simple: [groups[i].simple..., item]}]
			appendSpread()    [groups[:i]..., {spread: [groups[i].spread..., item.spread]}]
		)

		switch {
		case (i < 0 || groupIsSpread) && !isSpread:
			return appendNewSimple()
		case (i < 0 || !groupIsSpread) && isSpread:
			return appendNewSpread()
		case !groupIsSpread && !isSpread:
			return appendSimple()
		case groupIsSpread && isSpread:
			return appendSpread()
		}
	}, [])

	fn (
		appendSimples(code, group) formats("append(%s, %s)", code, join(", ", group))
		appendSpread(item, code)   formats("append(%s, %s)", code, item)
		appendSpreads(code, group) fold(appendSpread, code, group)
		appendGroups(groups)       fold(appendGroup, "[]interface{}{}", groups)
	)

	fn appendGroup(group, code) has("spread", group) ?
		appendSpreads(code, group.spread) :
		appendSimples(code, group.simple)

	return l.values
	-> map(compile)
	-> map(selectSpread)
	-> groupSpread
	-> appendGroups
}

fn compileEntry(e) formats(
	"\"%s\":%s"
	has("type", e.key) && e.key.type == "symbol" ?
		e.key.name :
		compile(e.key)
	compile(e.value)
)

fn compileStruct(s) {
	fn compileEntry(e) {
		let v compile(e.value)
		if e.type == "spread" {
			let (
				var    formats("sp := %s.(map[string]interface{});", v)
				assign "for k, v := range sp { s[k] = v };"
			)

			return joins("\n", var, assign)
		}

		if isString(e.key) {
			return formats("s[\"%s\"] = %s;", e.key, v)
		}
		
		if e.key.type == "symbol" {
			return formats("s[\"%s\"] = %s;", e.key.name, v)
		}

		return formats("s[%s] = %s;", compile(e.key), v)
	}

	let entries s.entries
	-> map(compileEntry)

	return formats(
		"func() interface{} { s := make(map[string]interface{}); %s; return s }()"
		entries -> join("")
	)
}

fn compileParamList(params, collectParam) {
	let ~ p []
	for i in 0:len(params) {
		p = [p..., formats("var _%s = a[%d]", params[i], i)]
	}

	if collectParam != "" {
		p = [p..., formats("var _%s = a[%d:]", collectParam, len(params))]
	}

	return join(";\n", p)
}

fn compileFunction(f) {
	let (
		scope      getScope(f.statement)
		paramNames f.collectParam == "" ? f.params : [f.params..., f.collectParam]
	)

	return formats(
		has("type", f.statement) && f.statement.type == "statement-list" ?
		"&mml.Function{
			F: func(a []interface{}) interface{} {
				var c interface{}
				mml.Nop(c)
				%s;
				%s;
				mml.Nop(%s);
				%s;
				return nil
			},
			FixedArgs: %d,
		}" :
		"&mml.Function{
			F: func(a []interface{}) interface{} {
				var c interface{}
				mml.Nop(c)
				%s;
				%s;
				mml.Nop(%s);
				return %s
			},
			FixedArgs: %d,
		}"
		compileParamList(f.params, f.collectParam)
		scope -> map(fn (s) formats("var _%s interface{}", s)) -> join(";\n")
		join(", ", map(strings.formatOne("_%s"), [scope..., paramNames...]))
		compile(f.statement)
		len(f.params)
	)
}

fn compileRangeExpression(e) formats(
	"%s:%s"
	has("from", e) ? compile(e.from) : ""
	has("to", e) ? compile(e.to) : ""
)

fn compileIndexer(i)
	!has("type", i.index) || i.index.type != "range-expression" ?
	formats(
		"mml.Ref(%s, %s)"
		compile(i.expression)
		compile(i.index)
	) :
	formats(
		"mml.RefRange(%s, %s, %s)"
		compile(i.expression)
		has("from", i.index) ? compile(i.index.from) : "nil"
		has("to", i.index) ? compile(i.index.to) : "nil"
	)

fn compileApplication(a) formats(
	has("type", a.function) && a.function.type == "function" ?
		"(%s).Call(%s)" :
		"%s.(*mml.Function).Call(%s)"
	compile(a.function)
	compileList({values: a.args})
)

fn compileUnary(u)
	u.op == code.logicalNot ?
	formats(
		isBool(u.arg) ? "!%s" : "!%s.(bool)"
		compile(u.arg)
	) :
	formats(
		"mml.UnaryOp(%d, %s)"
		u.op
		compile(u.arg)
	)

fn compileBinary(b) {
	if b.op != code.logicalAnd && b.op != code.logicalOr {
		return formats(
			"mml.BinaryOp(%s, %s, %s)"
			compile(b.op)
			compile(b.left)
			compile(b.right)
		)
	}

	fn isBoolOp(c)
		has("type", c) &&
		(c.type == "unary" && c.op == code.logicalNot) ||
		(c.type == "binary" && (c.op == code.logicalAnd || c.op == code.logicalOr))

	let ~ (
		left  compile(b.left)
		right compile(b.right)
	)

	if !isBool(b.left) && !isBoolOp(b.left) {
		left = left + ".(bool)"
	}

	if !isBool(b.right) && !isBoolOp(b.right) {
		right = right + ".(bool)"
	}

	let ~ op "&&"
	if b.op == code.logicalOr {
		op = "||"
	}

	return formats("(%s %s %s)", left, op, right)
}

fn compileTernary(c) formats(
	"func () interface{} { c = %s; if c.(bool) { return %s } else { return %s } }()"
	compile(c.condition)
	compile(c.consequent)
	compile(c.alternative)
)

fn compileIf(c)
	has("alternative", c) ?
	formats(
		"c = %s; if c.(bool) { %s } else { %s }"
		compile(c.condition)
		compile(c.consequent)
		compile(c.alternative)
	) :
	formats(
		"c = %s; if c.(bool) { %s }"
		compile(c.condition)
		compile(c.consequent)
	)

fn compileSwitch(s) {
	let (
		hasDefault  len(s.defaultStatements.statements) > 0
		cases       s.cases -> map(compile)
		def         hasDefault ? compile(s.defaultStatements) : ""
		defaultCode hasDefault ? formats("default:\n%s", def) : ""
	)

	return formats(
		"switch %s {\n%s\n}"
		has("expression", s) ? compile(s.expression) : ""
		(hasDefault ? [cases..., defaultCode] : cases) -> join("\n")
	)
}

fn compileSelect(s)
	s.cases
	-> map(compile)
	-> fn (c) (
		s.hasDefault ?
		[
			c...
			s.defaultStatements
			-> compile
			-> strings.formatOne("default:\n%s")
		] :
		c
	)
	-> join("\n")
	-> strings.formatOne("func() interface{} {\nselect {\n%s\n} }()")

fn compileRangeOver(r) {
	fn infiniteCounter() formats(
		"_%s := 0; true; _%s++"
		r.symbol
		r.symbol
	)

	fn withRangeExpression() formats(
		"_%s := %s; %s; _%s++"
		r.symbol
		has("from", r.expression) ? compile(r.expression.from) : "0"
		has("to", r.expression) ?
			formats("_%s < %s.(int)", r.symbol, compile(r.expression.to)) :
			"true"
		r.symbol
	)

	// TODO:
	// - should work for struct, too
	// - the arg should be called with nop()
	fn listStyleRange() formats(
		"_, _%s := range %s.([]interface{})"
		r.symbol
		compile(r.expression)
	)

	switch {
	case !has("expression", r):
		return infiniteCounter()
	case has("type", r.expression) && r.expression.type == "range-expression":
		return withRangeExpression()
	default:
		return listStyleRange()
	}
}

// TODO: nop call for the loop variable
fn compileLoop(l) formats(
	"for %s {\n%s\n}"
	has("expression", l) ? compile(l.expression) : ""
	compile(l.body)
)

fn compileDefinition(d)
	d.exported ?
	formats(
		"_%s = %s; exports[\"%s\"] = _%s"
		d.symbol
		compile(d.expression)
		d.symbol
		d.symbol
	) :
	formats(
		"_%s = %s"
		d.symbol
		compile(d.expression)
	)

fn compileAssign(a)
	a.capture.type == "symbol" ?
	formats(
		"%s = %s"
		compile(a.capture)
		compile(a.value)
	) :
	formats(
		"mml.SetRef(%s, %s, %s)"
		compile(a.capture.expression)
		compile(a.capture.index)
		compile(a.value)
	)

fn compileStatements(s) {
	let (
		scope      getScope(s...)
		scopeNames join(", ", map(strings.formatOne("_%s"), scope))
		statements map(compile, s) -> notEmpty -> join(";\n")
	)

	let scopeDefs scope
		-> map(fn (s) formats("var _%s interface{}", s))
		-> join(";\n")

	return formats(
		"%s;\nmml.Nop(%s);\n%s"
		scopeDefs
		scopeNames
		statements
	)
}

fn compileModule(m) formats(
	"%s"
	compileStatements(m.statements)
)

// TODO
fn getModuleName(path) path

fn compileUse(u) {
	switch {
	case u.capture == ".":
		let useStatement formats(
			"var __%s = mml.Modules.Use(\"%s.mml\");"
			getModuleName(u.path)
			u.path
		)

		let assigns map(fn (name)
			formats(
				"_%s = __%s[\"%s\"]"
				name
				getModuleName(u.path)
				name
			)
			u.exportNames
		)
		-> join(";\n")

		return joins(";", useStatement, assigns)
	case u.capture != "":
		return formats(
			"_%s = mml.Modules.Use(\"%s.mml\")"
			u.capture
			u.path
		)
	default:
		return formats(
			"_%s = mml.Modules.Use(\"%s.mml\")"
			getModuleName(u.path)
			u.path
		)
	}
}

// TODO: trim comments from everywhere

export fn compile(code) {
	switch {
	case isInt(code):
		return compileInt(code)
	case isFloat(code):
		return compileFloat(code)
	case isString(code):
		return compileString(code)
	case isBool(code):
		return compileBool(code)
	}

	switch code.type {
	case "comment":
		return compileComment(code)
	case "symbol":
		return compileSymbol(code)
	case "module":
		return compileModule(code)
	case "list":
		return compileList(code)
	case "entry":
		return compileEntry(code)
	case "struct":
		return compileStruct(code)
	case "function":
		return compileFunction(code)
	case "range-expression":
		return compileRangeExpression(code)
	case "indexer":
		return compileIndexer(code)
	case "spread":
		return compileSpread(code)
	case "function-application":
		return compileApplication(code)
	case "unary":
		return compileUnary(code)
	case "binary":
		return compileBinary(code)
	case "cond":
		return compileCond(code)
	case "switch-case":
		return compileCase(code)
	case "switch-statement":
		return compileSwitch(code)
	case "send":
		return compileSend(code)
	case "receive":
		return compileReceive(code)
	case "go":
		return compileGo(code)
	case "defer":
		return compileDefer(code)
	case "select-case":
		return compileCase(code)
	case "select":
		return compileSelect(code)
	case "range-over":
		return compileRangeOver(code)
	case "loop":
		return compileLoop(code)
	case "definition":
		return compileDefinition(code)
	case "definition-list":
		return compileDefinitions(code)
	case "assign":
		return compileAssign(code)
	case "assign-list":
		return compileAssigns(code)
	case "ret":
		return compileRet(code)
	case "control-statement":
		return compileControl(code)
	case "use":
		return compileUse(code)
	case "use-list":
		return compileUseList(code)
	default:
		return compileStatements(code.statements)
	}
}
