fn (
	fold(f, i, l)            len(l) == 0 ? i : fold(f, f(l[0], i), l[1:])
	foldr(f, i, l)           len(l) == 0 ? i : f(l[0], foldr(f, i, l[1:]))
	map(m, l)                fold(fn (c, r) [r..., m(c)], [], l)
	filter(p, l)             fold(fn (c, r) p(c) ? [r..., c] : r, [], l)
	not(x)                   !x
	yes(x)                   x
	ifErr(mod, f)            fn~ (a) mod(isError(a)) ? f(a) : a
	passErr(f)               ifErr(not, f)
	onlyErr(f)               ifErr(yes, f)
	anyErr(l)                fold(fn (c, r) isError(r) ? r : isError(c) ? c : [r..., c], [], l)
	firstOr(v, l)            len(l) > 0 ? l[0] : v
	join(j, s)               len(s) < 2 ? firstOr("", s) : s[0] + j + join(j, s[1:])
	joins(j, ...s)           join(j, s)
	joinTwo(j, left, right)  joins(j, left, right)
	destruct(s)              s -> keys -> map(fn (key) [key, s[key]])
	formats(f, ...a)         format(f, a)
	formatOne(f, a)          formats(f, a)
	passErrFormat(fmt, ...p) p -> anyErr -> passErr(format(fmt))
	notEmpty(l)              l -> filter(fn (s) s != "")
)

fn counter () {
	let ~ c -1
	return fn~ () {
		c = c + 1
		return c
	}
}

let enum counter

// TODO: should be a builtin fake function
fn~ log(...a) {
	a -> map(string) -> join(" ") -> stderr
	"\n" -> stderr
	return len(a) == 0 ? "" : a[len(a) - 1]
}

fn~ (
	readAll(input) input(-1)
	read(input)    input -> readAll -> passErr(parse)
)

fn escape(s) {
	if s == "" {
		return ""
	}

	let ~ first s[0]
	switch first {
	case "\b":
		first = "\\b"
	case "\f":
		first = "\\f"
	case "\n":
		first = "\\n"
	case "\r":
		first = "\\r"
	case "\t":
		first = "\\t"
	case "\v":
		first = "\\v"
	case "\"":
		first = "\\\""
	case "\\":
		first = "\\\\"
	}

	return first + escape(s[1:])
}

let (
	compileInt   string
	compileFloat string
	compileBool  string
)

fn (
	mapCompile(l)         l -> map(compile) -> anyErr
	mapCompileJoin(j, l)  l -> mapCompile -> passErr(join(j))
	compileComment(_)     ""
	compileString(s)      formats("\"%s\"", escape(s))
	compileSymbol(s)      formats("_%s", s.name)
	compileEntry(e)       passErrFormat("\"%s\":%s", compile(e.key), compile(e.value))
	compileEntries(e)     mapCompileJoin(",", e)
	compileStructure(s)   passErrFormat("map[string]interface{}{%s}", compileEntries(s.entries))
	compileCond(c)        c.ternary ? compileTernary(c) : compileIf(c)
	compileIndexer(i)     passErrFormat("%s[%s]", compile(i.expression), compile(i.index))
	compileSpread(s)      passErrFormat("%s...", compile(s.value))
	compileCase(c)        passErrFormat("case %s:\n%s", compile(c.expression), compile(c.body))
	compileSend(s)        passErrFormat("%s <- %s", compile(s.channel), compile(s.value))
	compileReceive(r)     passErrFormat("<- %s", compile(r.channel))
	compileGo(g)          passErrFormat("go %s", compile(g.application))
	compileDefer(d)       passErrFormat("defer %s", compile(d.application))
	compileDefinition(d)  passErrFormat("var _%s = %s", d.symbol, compile(d.expression))
	compileDefinitions(l) mapCompileJoin(";\n", l.definitions)
	compileAssign(a)      passErrFormat("%s = %s", compile(a.capture), compile(a.value))
	compileAssigns(l)     mapCompileJoin(";\n", l.assignments)
	compileStatements(s)  s -> mapCompile -> passErr(notEmpty) -> passErr(join(";\n"))
	compileRet(r)         passErrFormat("return %s", compile(r.value))
	compileControl(c)     c.control == breakControl ? "break" : "continue"
	compileModule(m)      compileStatements(m.statements)
)

fn compileList(l) {
	let compileValues mapCompile

	fn (
		isSpread(c)     len(c) > 3 && c[len(c) - 3:] == "..."
		selectSpread(c) isSpread(c) ? {spread: c} : c
	)

	let groupSpread fold(fn (item, groups) {
		let (
			i             len(groups) - 1
			isSpread      has("spread", item)
			groupIsSpread i >= 0 && has("spread", groups[i])
		)

		fn (
			appendNewSimple() [groups..., {simple: [item]}]
			appendNewSpread() [groups..., {spread: [item.spread]}]
			appendSimple()    [groups[:i]..., {simple: [groups[i].simple..., item]}]
			appendSpread()    [groups[:i]..., {spread: [groups[i].spread..., item.spread]}]
		)

		switch {
		case (i < 0 || groupIsSpread) && !isSpread:
			return appendNewSimple()
		case (i < 0 || !groupIsSpread) && isSpread:
			return appendNewSpread()
		case !groupIsSpread && !isSpread:
			return appendSimple()
		case groupIsSpread && isSpread:
			return appendSpread()
		}
	}, [])

	fn (
		appendSimples(code, group) formats("append(%s, %s)", code, join(", ", group))
		appendSpread(item, code)   formats("append(%s, %s)", code, item)
		appendSpreads(code, group) fold(appendSpread, code, group)
		appendGroups(groups)       fold(appendGroup, "[]interface{}{}", groups)
	)

	fn appendGroup(group, code) has("spread", group) ?
		appendSpreads(code, group.spread) :
		appendSimples(code, group.simple)

	return l.values
	-> compileValues
	-> passErr(map(selectSpread))
	-> passErr(groupSpread)
	-> passErr(appendGroups)
}

fn compileParamList(params, collectParam) {
	let ~ p []
	for i in 0:len(params) {
		p = [p..., formats("var _%s = a[%d]", params[i], i)]
	}

	if collectParam != "" {
		p = [p..., formats("var _%s = a[%d:]", collectParam, len(params))]
	}

	return join(";\n", p)
}

fn compileFunction(f) {
	let multipleStatements has("type", f.statement) && f.statement.type == "statement-list"
	let fmt multipleStatements ?
		"&cfunction{
			f: func(a []interface{}) interface{} {
				%s;
				%s;
				return nil
			},
		}" :
		"&cfunction{
			f: func(a []interface{}) interface{} {
				%s;
				return %s
			},
		}"

	let p compileParamList(f.params, f.collectParam)
	if isError(p) {
		return p
	}

	let s compile(f.statement)
	if isError(s) {
		return s
	}

	return formats(fmt, p, s)
}

fn compileRangeExpression(e) passErrFormat(
	"%s:%s"
	has("from", e) ? compile(e.from) : ""
	has("to", e) ? compile(e.to) : ""
)

fn compileApplication(a) passErrFormat(
	"%s.(*cfunction).call(%s)"
	compile(a.function)
	compileList({values: a.args})
)

let (
	unaryOp    enum()
	binaryNot  unaryOp()
	plus       unaryOp()
	minus      unaryOp()
	logicalNot unaryOp()
)

fn compileUnaryOp(o) {
	switch o {
	case binaryNot:
		return "^"
	case plus:
		return "+"
	case minus:
		return "-"
	case logicalNot:
		return "!"
	default:
		return error(formats("unsupported code: %v"), o)
	}
}

fn compileUnary(u) passErrFormat(
	"%s%s",
	compileUnaryOp(u.op)
	compile(u.arg)
)

let (
	binaryOp    enum()
	binaryAnd   binaryOp()
	binaryOr    binaryOp()
	xor         binaryOp()
	andNot      binaryOp()
	lshift      binaryOp()
	rshift      binaryOp()
	mul         binaryOp()
	div         binaryOp()
	mod         binaryOp()
	add         binaryOp()
	sub         binaryOp()
	eq          binaryOp()
	notEq       binaryOp()
	less        binaryOp()
	lessOrEq    binaryOp()
	greater     binaryOp()
	greaterOrEq binaryOp()
	logicalAnd  binaryOp()
	logicalOr   binaryOp()
)

fn compileBinaryOp(o) {
	switch o {
	case binaryAnd:
		return "&"
	case binaryOr:
		return "|"
	case xor:
		return "^"
	case andNot:
		return "&^"
	case lshift:
		return "<<"
	case rshift:
		return ">>"
	case mul:
		return "*"
	case div:
		return "/"
	case mod:
		return "%"
	case add:
		return "+"
	case sub:
		return "-"
	case eq:
		return "=="
	case notEq:
		return "!="
	case less:
		return "<"
	case lessOrEq:
		return "<="
	case greater:
		return ">"
	case greaterOrEq:
		return ">="
	case logicalAnd:
		return "&&"
	case logicalOr:
		return "||"
	default:
		return error(formats("unsupported code: %v"), o)
	}
}

fn compileBinary(b) passErrFormat(
	"(%s %s %s)"
	compile(b.left)
	compileBinaryOp(b.op)
	compile(b.right)
)

fn compileTernary(c) passErrFormat(
	"func () interface{} { if %s { return %s } else { return %s } }()"
	compile(c.condition)
	compile(c.consequent)
	compile(c.alternative)
)

fn compileIf(c)
	has("alternative", c) ?
	passErrFormat(
		"if %s { %s } else { %s }"
		compile(c.condition)
		compile(c.consequent)
		compile(c.alternative)
	) :
	passErrFormat(
		"if %s { %s }"
		compile(c.condition)
		compile(c.consequent)
	)

fn compileSwitch(s) {
	let (
		hasDefault len(s.defaultStatements.statements) > 0
		exp has("expression", s) ? compile(s.expression) : ""
	)

	if isError(exp) {
		return exp
	}

	let cases s.cases -> map(compile) -> anyErr
	if isError(cases) {
		return cases
	}

	let def hasDefault ? compile(s.defaultStatements) : ""
	if isError(def) {
		return def
	}

	let (
		defaultCode hasDefault ? formats("default:\n%s", def) : ""
		casesCode join("\n", hasDefault ? [cases..., defaultCode] : cases)
	)

	return formats("switch %s {\n%s\n}", exp, casesCode)
}

fn compileSelect(s)
	s.cases
	-> map(compile)
	-> fn (c) (
		s.hasDefault ?
		[c..., s.defaultStatements -> compile -> passErr(formatOne("default:\n%s")) ] :
		c
	)
	-> anyErr
	-> passErr(join("\n"))
	-> passErr(formatOne("func() interface{} {\nselect {\n%s\n} }()"))

fn compileRangeOver(r) {
	fn infiniteCounter() passErrFormat(
		"%s := 0; true; %s++"
		r.symbol
		r.symbol
	)

	fn withRangeExpression() passErrFormat(
		"%s := %s; %s; %s++"
		r.symbol
		has("from", r.expression) ? compile(r.expression.from) : "0"
		has("to", r.expression) ?
			formats("%s < %s", r.symbol, compile(r.expression.to)) :
			"true"
		r.symbol
	)

	fn listStyleRange() passErrFormat(
		"_, %s := range %s"
		r.symbol
		compile(r.expression)
	)

	switch {
	case !has("expression", r):
		return infiniteCounter()
	case has("type", r.expression) && r.expression.type == "range-expression":
		return withRangeExpression()
	default:
		return listStyleRange()
	}
}

fn compileLoop(l) passErrFormat(
	"for %s {\n%s\n}"
	has("expression", l) ? compile(l.expression) : ""
	compile(l.body)
)

let (
	controlStatement enum()
	breakControl     controlStatement()
	continueControl  controlStatement()
)

fn compile(code) {
	switch {
	case isInt(code):
		return compileInt(code)
	case isFloat(code):
		return compileFloat(code)
	case isString(code):
		return compileString(code)
	case isBool(code):
		return compileBool(code)
	}

	switch code.type {
	case "comment":
		return compileComment(code)
	case "symbol":
		return compileSymbol(code)
	case "module":
		return compileModule(code)
	case "list":
		return compileList(code)
	case "entry":
		return compileEntry(code)
	case "structure":
		return compileStructure(code)
	case "function":
		return compileFunction(code)
	case "range-expression":
		return compileRangeExpression(code)
	case "indexer":
		return compileIndexer(code)
	case "spread":
		return compileSpread(code)
	case "function-application":
		return compileApplication(code)
	case "unary":
		return compileUnary(code)
	case "binary":
		return compileBinary(code)
	case "cond":
		return compileCond(code)
	case "switch-case":
		return compileCase(code)
	case "switch-statement":
		return compileSwitch(code)
	case "send":
		return compileSend(code)
	case "receive":
		return compileReceive(code)
	case "go":
		return compileGo(code)
	case "defer":
		return compileDefer(code)
	case "select-case":
		return compileCase(code)
	case "select":
		return compileSelect(code)
	case "range-over":
		return compileRangeOver(code)
	case "loop":
		return compileLoop(code)
	case "definition":
		return compileDefinition(code)
	case "definition-list":
		return compileDefinitions(code)
	case "assign":
		return compileAssign(code)
	case "assign-list":
		return compileAssigns(code)
	case "ret":
		return compileRet(code)
	case "control-statement":
		return compileControl(code)
	case "statement-list":
		return compileStatements(code.statements)
	default:
		return error(formats("unsupported code: %v", code))
	}
}

let write stdout
write("package mml

type cfunction struct {
	f         func([]interface{}) interface{}
	fixedArgs int
	args      []interface{}
}

func (f *cfunction) bind(a []interface{}) *cfunction {
	b := *f
	b.args = a
	return &b
}

func (f *cfunction) call(a []interface{}) interface{} {
	a = append(f.args, a...)
	if len(a) < f.fixedArgs {
		return f.bind(a)
	}

	return f.f(a)
}

func init() {
")

stdin
-> read
-> passErr(compile)
-> passErr(write)
-> onlyErr(log)

write("}")
