fn (
	fold(f, i, l)            len(l) == 0 ? i : fold(f, f(l[0], i), l[1:])
	foldr(f, i, l)           len(l) == 0 ? i : f(l[0], foldr(f, i, l[1:]))
	map(m, l)                fold(fn (c, r) [r..., m(c)], [], l)
	filter(p, l)             fold(fn (c, r) p(c) ? [r..., c] : r, [], l)
	not(x)                   !x
	yes(x)                   x
	ifErr(mod, f)            fn~ (a) mod(isError(a)) ? f(a) : a
	passErr(f)               ifErr(not, f)
	onlyErr(f)               ifErr(yes, f)
	anyErr(l)                fold(fn (c, r) isError(r) ? r : isError(c) ? c : [r..., c], [], l)
	firstOr(v, l)            len(l) > 0 ? l[0] : v
	join(j, s)               len(s) < 2 ? firstOr("", s) : s[0] + j + join(j, s[1:])
	joins(j, ...s)           join(j, s)
	joinTwo(j, left, right)  joins(j, left, right)
	destruct(s)              s -> keys -> map(fn (key) [key, s[key]])
	formats(f, ...a)         format(f, a)
	formatOne(f, a)          formats(f, a)
	passErrFormat(fmt, ...p) p -> anyErr -> passErr(format(fmt))
	notEmpty(l)              l -> filter(fn (s) s != "")
)

fn counter () {
	let ~ c -1
	return fn~ () {
		set c c + 1
		return c
	}
}

let enum counter

// TODO: should be a builtin fake function
fn~ log(...a) {
	a -> map(string) -> join(" ") -> stderr
	"\n" -> stderr
	return len(a) == 0 ? "" : a[len(a) - 1]
}

fn~ (
	readAll(input) input(-1)
	read(input)    input -> readAll -> passErr(parse)
)

fn escape(s) {
	if s == "" {
		return ""
	}

	let ~ first s[0]
	switch first {
	case "\b":
		first = "\\b"
	case "\f":
		first = "\\f"
	case "\n":
		first = "\\n"
	case "\r":
		first = "\\r"
	case "\t":
		first = "\\t"
	case "\v":
		first = "\\v"
	}

	return first + escape(s[1:])
}

let (
	compileInt   string
	compileFloat string
	compileBool  string
)

fn (
	mapCompile(l)         l -> map(compile) -> anyErr
	mapCompileJoin(j, l)  l -> mapCompile -> passErr(join(j))
	compileComment(_)     ""
	compileString(s)      formats("\"%s\"", escape(s))
	compileSymbol(s)      s.name
	compileListItems(i)   mapCompileJoin(",", i)
	compileList(l)        passErrFormat("[]interface{}{%s}", compileListItems(l.values))
	compileEntry(e)       passErrFormat("\"%s\":%s", compile(e.key), compile(e.value))
	compileEntries(e)     mapCompileJoin(",", e)
	compileStructure(s)   passErrFormat("map[string]interface{}{%s}", compileEntries(s.entries))
	compileIndexer(i)     passErrFormat("%s[%s]", compile(i.expression), compile(i.index))
	compileApplication(a) passErrFormat("%s(%s)", compile(a.function), compileListItems(a.args))
	compileCase(c)        passErrFormat("case %s:\n%s", compile(c.expression), compile(c.body))
	compileSend(s)        passErrFormat("%s <- %s", compile(s.channel), compile(s.value))
	compileReceive(r)     passErrFormat("<- %s", compile(r.channel))
	compileGo(g)          passErrFormat("go %s", compile(g.application))
	compileDefer(d)       passErrFormat("defer %s", compile(d.application))
	compileDefinition(d)  passErrFormat("%s := %s", d.symbol, compile(d.expression))
	compileStatements(s)  s -> mapCompile -> passErr(notEmpty) -> passErr(join(";\n"))
	compileModule(m)      compileStatements(m.statements)
)

fn compileParamList(params, collectParam)
	params
	-> join(",")
	-> formatOne("%s interface{}")
	-> fn (p) collectParam == "" ?
		p :
		formats("%s, %s ...interface{}", p, collectParam)

fn compileFunction(f) passErrFormat(
	"func(%s) interface{} {%s}"
	compileParamList(f.params, f.collectParam)
	compile(f.statement)
)

let (
	unaryOp    enum()
	binaryNot  unaryOp()
	plus       unaryOp()
	minus      unaryOp()
	logicalNot unaryOp()
)

fn compileUnaryOp(o) {
	switch o {
	case binaryNot:
		return "^"
	case plus:
		return "+"
	case minus:
		return "-"
	case logicalNot:
		return "!"
	default:
		return error(formats("unsupported code: %v"), o)
	}
}

fn compileUnary(u) passErrFormat(
	"%s%s",
	compileUnaryOp(u.op)
	compile(u.arg)
)

let (
	binaryOp    enum()
	binaryAnd   binaryOp()
	binaryOr    binaryOp()
	xor         binaryOp()
	andNot      binaryOp()
	lshift      binaryOp()
	rshift      binaryOp()
	mul         binaryOp()
	div         binaryOp()
	mod         binaryOp()
	add         binaryOp()
	sub         binaryOp()
	eq          binaryOp()
	notEq       binaryOp()
	less        binaryOp()
	lessOrEq    binaryOp()
	greater     binaryOp()
	greaterOrEq binaryOp()
	logicalAnd  binaryOp()
	logicalOr   binaryOp()
)

fn compileBinaryOp(o) {
	switch o {
	case binaryAnd:
		return "&"
	case binaryOr:
		return "|"
	case xor:
		return "^"
	case andNot:
		return "&^"
	case lshift:
		return "<<"
	case rshift:
		return ">>"
	case mul:
		return "*"
	case div:
		return "/"
	case mod:
		return "%"
	case add:
		return "+"
	case sub:
		return "-"
	case eq:
		return "=="
	case notEq:
		return "!="
	case less:
		return "<"
	case lessOrEq:
		return "<="
	case greater:
		return ">"
	case greaterOrEq:
		return ">="
	case logicalAnd:
		return "&&"
	case logicalOr:
		return "||"
	default:
		return error(formats("unsupported code: %v"), o)
	}
}

fn compileBinary(b) passErrFormat(
	"(%s %s %s)"
	compile(b.left)
	compileBinaryOp(b.op)
	compile(b.right)
)

fn compileCond(c)
	has("alternative", c) ?
	passErrFormat(
		"func () interface{} { if %s { return %s } else { return %s } }()"
		compile(c.condition)
		compile(c.consequent)
		compile(c.alternative)
	) :
	passErrFormat(
		"func () interface{} { if %s { return %s } }()"
		compile(c.condition)
		compile(c.consequent)
	)

fn compileSwitch(s)
	(has("expression", s) ? compile(s.expression) : "")
	-> fn (c) [c, map(compile, s.cases)]
	-> fn (c) (
		len(s.defaultStatements.statements) > 0 ?
		[
			c[0]
			[
				c[1]...
				s.defaultStatements
				-> compile
				-> passErr(formatOne("default:\n%s"))
			]
		] :
		c
	)
	-> fn (c) isError(c[0]) ? c[0] : isError(anyErr(c[1])) ? anyErr(c[1]) : c
	-> passErr(fn (c) [c[0], join("\n", c[1])])
	-> passErr(format("func() interface{} {\nswitch %s {\n%s\n} }()"))

fn compileSelect(s)
	s.cases
	-> map(compile)
	-> fn (c) (
		s.hasDefault ?
		[c..., s.defaultStatements -> compile -> passErr(formatOne("default:\n%s")) ] :
		c
	)
	-> anyErr
	-> passErr(join("\n"))
	-> passErr(formatOne("func() interface{} {\nselect {\n%s\n} }()"))

fn compile(code) {
	switch {
	case isInt(code):
		return compileInt(code)
	case isFloat(code):
		return compileFloat(code)
	case isString(code):
		return compileString(code)
	case isBool(code):
		return compileBool(code)
	}

	switch code.type {
	case "comment":
		return compileComment(code)
	case "symbol":
		return compileSymbol(code)
	case "module":
		return compileModule(code)
	case "list":
		return compileList(code)
	case "entry":
		return compileEntry(code)
	case "structure":
		return compileStructure(code)
	case "function":
		return compileFunction(code)
	case "indexer":
		return compileIndexer(code)
	case "function-application":
		return compileApplication(code)
	case "unary":
		return compileUnary(code)
	case "binary":
		return compileBinary(code)
	case "cond":
		return compileCond(code)
	case "switch-case":
		return compileCase(code)
	case "switch-statement":
		return compileSwitch(code)
	case "send":
		return compileSend(code)
	case "receive":
		return compileReceive(code)
	case "go":
		return compileGo(code)
	case "defer":
		return compileDefer(code)
	case "select-case":
		return compileCase(code)
	case "select":
		return compileSelect(code)
	case "definition":
		return compileDefinition(code)
	case "statement-list":
		return compileStatements(code.statements)
	default:
		return error(formats("unsupported code: %v", code))
	}
}

let write stdout

stdin
-> read
-> passErr(compile)
-> passErr(write)
-> onlyErr(log)
