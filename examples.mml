// -- http listener

import http "mml/http"

type handler http.handler

fn~ handler(writer, _) {
	fprintln(writer, "Hello, world!")
}

http.listen(":8080", handler)

// -- proc every number in an arbitrary json

fn proc(n) 2 * n

fn procInJson(data) {
	switch type data {
		case number: proc(data)
		case []: map(procInJson, data)
		case {}: mapStruct(procInJson, data)
		default: j
	}
}

switch {
	case true: 1
	case value == 1: 2
	case match(list[0]): 3
	case a = list[0]: 4
	case match(a = list[0]): 5
	case a = list[0], b = list[1:]: 6
	case value == 2, value == 3, value == 4: 7
	case match(struct.a): 8
	case match(struct["a"]): 9
	case a = struct.a: 10
	case _ = struct.a: 11
	case type value number: 12
	default: 13
}

// this is not needed
switch match {
	case list[0]: 1
	case struct.a: 2
	default: 3
}

switch type value {
	case number: 1
	default: 2
}

swtich value {
	case 0: 1
	default: 2
}

// -- strings

let reverseString bind(fold, appendString, "")

fn reverseString(s) = fold(appendString, "", s)

// -- loops

let list = [1, 2, 3]

for item in list {
	print(item)
}

for index in 0:len(list) {
	print(list[index])
}

let~ ml = [1, 2, 3]

for len(ml) > 0 {
	print(ml[0])
	ml = ml[1:]
}

for {
	if len(ml) == 0 {
		break
	}

	print(ml[0])
	ml = ml[1:]
}

let s = {a: 1, b: 2, c: 3}

for v in s {
	print(v)
}

for k in keys(s) {
	print(s[k])
}

// canonically:
each(print, l)
each(print, s)

// -- matches

// match() can be used as a boolean expression, should it?

let l = [1, 2, 3]

a = l[0] ? a : 0

fn filterNumbers(l) a = l[0], rest = l[1:] ?
	type a number ?
		[a, filterNumbers(rest)...] :
		filterNumbers(rest) :
	[]

fn filterNumbers(l) {
	if a = l[0], rest = l[1:] {
		let frest = filterNumbers(rest)
		type a number ? [a, frest...] : frest
	} else {
		[]
	}
}

fn filterNumbersLoop(l) {
	let~ ml = []
	for n in l {
		if type n number {
			ml = [ml..., n]
		}
	}

	ml
}

let filterNumbersCanon = bind(filter, isNumber)

switch {
	case a == 1: a + 1
	case match(a {foo: number}): a.foo
	case n = a[0]: n
	case n = <-a: n // here and in ifs, match is optional
	default: 0
}

// -- lists

fn reverse(l)
	match(first = l[0], rest = l[1:]) ?
		[reverse(rest)..., first] :
		[]

fn reverse(l) {
	if first l[0], rest l[1:] {
		[reverse(rest)..., first]
	} else {
		[]
	}
}

// should use ^ rather instead of ~, and use pow() for power of
fn reverseLoop(l) {
	let r = ~[l...]
	for i in 0:len(r) / 2 {
		let~ a = r[i]
		r[i] = r[len(r) - i]
		r[len(r) - i] = a
	}

	[r...] // the result is converted into an immutable list
}

type sort fn (less fn (a, a) bool, [a]) [a]
fn sort(less, l) { /* impl */ }

sort(less, l)

type sortAnything fn~ (
	less fn (a int, a int) bool
	swap fn~ (a int, a int)
	len int
)
fn~ sortAnything(less, swap, len) { /* impl */ }

type sortm fn~ (less fn (a, a) bool, ~[a])
fn~ sortm(less, l) sortAnything(
	fn (i, j) less(l[i], l[j])
	fn~ (i, j) {
		let tmp = l[i]
		l[i] = l[j]
		l[j] = tmp
	}
	len(l)
)

// -- structures

let s1 {s0..., mark: true}

// how to filter structures?

// functions

fn emptyStructure() {}
fn noopFunction() {;}

// go routines

let c channel()
spawn work(c)
println(receive(c))

// or:
let c <>
~work(c)
println(<-c)

// alternative for mutation:
let~ a 1
a = 2
set a 3

// formatting with options:
#! mml

import (
	format "mml/format"
	lang   "mml/lang"
)

let options {
	letEquals: format.never,
	setEquals: format.always,
}

format.withOptions(options).copy(stdin, stdout)

// reflection:

code(a)
doc(a)
type(a)
typeFull(a)

// symbols:

let j json.parse(stdin)
if isError(j) {
	log(j)
	sys.exit(-1)
}

println(j."a json field with spaces")

// find the first even number:

fn findEven(numbers) {
	let~ result 0
	for n in numbers {
		if n % 2 == 0 {
			set result n
			break
		}
	}

	result
}

type find fn (fn (a) bool, [a]) a|error

// --

fn find(predicate, list) {
	let~ result error("empty list")
	for item in list {
		if predicate(item) {
			set result item
			break
		}
	}

	result
}

type isEven fn (int) bool
fn isEven(n) n % 2 == 0

type findEven fn ([int]) int
fn findEven(numbers) {
	let firstEven = find(isEven, numbers)
	firstEven ? firstEven : 0
}

// --

type numberOrZero fn (int|error) int
fn numberOrZero(value) value ? value : 0

type findEven fn ([int]) int
fn findEven(numbers) {
	numberOrZero(find(isEven, numbers))
}

// --

type findEven fn ([int]) int
fn findEven(numbers) {
	numbers -> bind(find, isEven) -> numberOrZero
}

// --

type findEven fn ([int]) int
fn findEven(numbers) {
	numbers -> find(isEven) -> numberOrZero
}

// --

type findEven fn ([int]) int
fn isEven(n) n % 2 == 0
fn numberOrZero(value) value ? value : 0
export let findEven find(isEven) -> numberOrZero

// --

type node struct {
	children []node
	value int

	// other fields ...
}

func filterEven(forest []*node, query int) []*node {
	var even []*node
	for _, n := range forest {
		evenChildren := filterEven(n.children)
		if len(evenChildren) > 0 || n.value == query {
			nv := *n
			n = &nv
			n.children = evenChildren
			even = append(even, n)
		}
	}

	return even
}

// --

type alias node(a) {value: a, children: [node(a)]}
type filterForest(t) fn (fn (t) bool, [node(t)]) [node(t)]
fn filterForest(predicate, forest) fold(
	fn (item, result) {
		let matchingChildren filterForest(item.children)
		len(matchingChildren) > 0 || predicate(item) ?
			[{item..., children: matchingChildren}, result...] :
			result
	},
	[],
	forest
)

let filterEven filterForest(isEven)
let filterAllCaps filterForest(allCaps)
