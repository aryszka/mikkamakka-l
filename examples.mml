// -- http listener

import http "mml/http"

type handler http.handler

fn~ handler(writer, _) {
	fprintln(writer, "Hello, world!")
}

http.listen(":8080", handler)

// -- proc every number in an arbitrary json

fn proc(n) 2 * n

fn procInJson(data) {
	switch type data {
		case number: proc(data)
		case []: map(procInJson, data)
		case {}: mapStruct(procInJson, data)
		default: j
	}
}

switch {
	case true: 1
	case value == 1: 2
	case match(list[0]): 3
	case a = list[0]: 4
	case match(a = list[0]): 5
	case a = list[0], b = list[1:]: 6
	case value == 2, value == 3, value == 4: 7
	case match(struct.a): 8
	case match(struct["a"]): 9
	case a = struct.a: 10
	case _ = struct.a: 11
	case type value number: 12
	default: 13
}

// this is not needed
switch match {
	case list[0]: 1
	case struct.a: 2
	default: 3
}

switch type value {
	case number: 1
	default: 2
}

swtich value {
	case 0: 1
	default: 2
}

// -- strings

let reverseString bind(fold, appendString, "")

fn reverseString(s) = fold(appendString, "", s)

// -- loops

let list = [1, 2, 3]

for item in list {
	print(item)
}

for index in 0:len(list) {
	print(list[index])
}

let~ ml = [1, 2, 3]

for len(ml) > 0 {
	print(ml[0])
	ml = ml[1:]
}

for let i = 0; i < n; i++ {
}

for i in 0:n {
}

for {
	if len(ml) == 0 {
		break
	}

	print(ml[0])
	ml = ml[1:]
}

let s = {a: {foo: 4}, b: 2, c: 3}
s.a.foo

fn add(x, y) x + y
let inc add(1)

let n 3
n.inc()

f(n.inc)

g(3.f())

for v in s {
	print(v)
}

for k in keys(s) {
	print(s[k])
}

// canonically:
each(print, l)
each(print, s)

// -- matches

// match() can be used as a boolean expression, should it?

let l = [1, 2, 3]

a = l[0] ? a : 0

fn filterNumbers(l) a = l[0], rest = l[1:] ?
	type a number ?
		[a, filterNumbers(rest)...] :
		filterNumbers(rest) :
	[]

fn filterNumbers(l) {
	if a = l[0], rest = l[1:] {
		let frest = filterNumbers(rest)
		type a number ? [a, frest...] : frest
	} else {
		[]
	}
}

fn filterNumbersLoop(l) {
	let~ ml = []
	for n in l {
		if type n number {
			ml = [ml..., n]
		}
	}

	ml
}

let filterNumbersCanon = bind(filter, isNumber)

switch {
	case a == 1: a + 1
	case match(a {foo: number}): a.foo
	case n = a[0]: n
	case n = <-a: n // here and in ifs, match is optional
	default: 0
}

// -- lists

fn reverse(l)
	match(first = l[0], rest = l[1:]) ?
		[reverse(rest)..., first] :
		[]

fn reverse(l) {
	if first l[0], rest l[1:] {
		[reverse(rest)..., first]
	} else {
		[]
	}
}

// should use ^ rather instead of ~, and use pow() for power of
fn reverseLoop(l) {
	let r = ~[l...]
	for i in 0:len(r) / 2 {
		let~ a = r[i]
		r[i] = r[len(r) - i]
		r[len(r) - i] = a
	}

	[r...] // the result is converted into an immutable list
}

type sort fn (less fn (a, a) bool, [a]) [a]
fn sort(less, l) { /* impl */ }

sort(less, l)

type sortAnything fn~ (
	less fn (a int, a int) bool
	swap fn~ (a int, a int)
	len int
)
fn~ sortAnything(less, swap, len) { /* impl */ }

type sortm fn~ (less fn (a, a) bool, ~[a])
fn~ sortm(less, l) sortAnything(
	fn (i, j) less(l[i], l[j])
	fn~ (i, j) {
		let tmp = l[i]
		l[i] = l[j]
		l[j] = tmp
	}
	len(l)
)

// -- structures

let s1 {s0..., mark: true}

// how to filter structures?

// functions

fn emptyStructure() {}
fn noopFunction() {;}

// go routines

let c channel()
spawn work(c)
println(receive(c))

// or:
let c <>
~work(c)
println(<-c)

// alternative for mutation:
let~ a 1
a = 2
set a 3

// formatting with options:
#! mml

import (
	format "mml/format"
	lang   "mml/lang"
)

let options {
	letEquals: format.never,
	setEquals: format.always,
}

format.withOptions(options).copy(stdin, stdout)

// reflection:

code(a)
doc(a)
type(a)
typeFull(a)

// symbols:

let j json.parse(stdin)
if isError(j) {
	log(j)
	sys.exit(-1)
}

println(j."a json field with spaces")

// find the first even number:

fn findEven(numbers) {
	let~ result 0
	for n in numbers {
		if n % 2 == 0 {
			set result n
			break
		}
	}

	result
}

type find fn (fn (a) bool, [a]) a|error

// --

fn find(predicate, list) {
	let~ result error("empty list")
	for item in list {
		if predicate(item) {
			set result item
			break
		}
	}

	result
}

type isEven fn (int) bool
fn isEven(n) n % 2 == 0

type findEven fn ([int]) int
fn findEven(numbers) {
	let firstEven = find(isEven, numbers)
	firstEven ? firstEven : 0
}

// --

type numberOrZero fn (int|error) int
fn numberOrZero(value) value ? value : 0

type findEven fn ([int]) int
fn findEven(numbers) {
	numberOrZero(find(isEven, numbers))
}

// --

type findEven fn ([int]) int
fn findEven(numbers) {
	numbers -> bind(find, isEven) -> numberOrZero
}

// --

let (
	a f(x)
	b g(a)
	c h(b)
)

let c h(g(f(x)))
let c fn(x) { let a f(x); let b g(a); h(b) }(x)

let c x -> f -> g -> h

// --

type findEven fn ([int]) int
fn findEven(numbers) {
	numbers -> find(isEven) -> numberOrZero
}

// --

type findEven fn ([int]) int
fn isEven(n) n % 2 == 0
fn numberOrZero(value) value ? value : 0
export let findEven find(isEven) -> numberOrZero

// --

type node struct {
	children []node
	value int

	// other fields ...
}

func filterEven(forest []*node, query int) []*node {
	var even []*node
	for _, n := range forest {
		evenChildren := filterEven(n.children)
		if len(evenChildren) > 0 || n.value == query {
			nv := *n
			n = &nv
			n.children = evenChildren
			even = append(even, n)
		}
	}

	return even
}

// --

type alias node(a) {value: a, children: [node(a)]}
type filterForest(t) fn (fn (t) bool, [node(t)]) [node(t)]
fn forestFold(predicate, item, result) {
	let matchingChildren filterForest(item.children)
	if len(matchingChildren) > 0 || predicate(item) {
		[{item..., children: matchingChildren}, result...]
	} else {
		result
	}
}
fn filterForest(predicate, forest) {
	fold(forestFold(predicate), [], forest)
}

let filterEven filterForest(isEven)
let filterAllCaps filterForest(allCaps)

test "filter forest" {
	test "even" {
		fn even(n) n % 2 == 0
		let value field("value")
		let predicate value -> even
		let data = [{
			value: 1,
			children: [{
				value: 2
				children: []
			}, {
				value: 3
				children: []
			}]
		}, {
			value: 4
			children: []
		}, {
			value: 5
			children: []
		}]
		let result = filterForest(predicate, data)
		match(result, [{
			value: 1
			children: [{
				value: 2
				children: []
			}]
		}, {
			value: 4
			children: []
		}])
	}

	test "all caps" {
		import rx "mml/regexp"

		let predicate field("value") -> rx.match("^[A-Z]*$")

		let data = [{
			value: "foo",
			children: [{
				value: "BAR"
				children: []
			}, {
				value: "baZ"
				children: []
			}]
		}, {
			value: "QUX"
			children: []
		}, {
			value: "QUuX"
			children: []
		}]

		let result = filterForest(predicate, data)
		match(result, [{
			value: "foo"
			children: [{
				value: "BAR"
				children: []
			}]
		}, {
			value: "QUX"
			children: []
		}])
	}
}

// --

import rand "mml/rand"

fn~ produce(out, toggle) {
	for {
		select {
		case out <- rand.int():
		case <-toggle:
			if blocked(out) {
				unblock(out)
			} else {
				block(out)
			}
		}
	}
}

fn~ consume(in) {
	for {
		println(<-in)
	}
}

fn~ control(toggle) {
	for {
		readln()
		toggle <- {}
	}
}

let inOut <>
let toggle <>
go produce(inOut, toggle)
go consume(inOut)
go control(toggle)
select {}

// --

// use case because then it can be a declaration

switch {
	case a == 1: true
	default: false
}

switch a {
	case 1: true
	default: false
}

type list [int|string]
let list [1, 2, "foo", 4] // min-length = 4, 
list[3]

let s {foo: 3}
let t {bar: 4, foo: 5, s...}

f(b, c...)

match {
	case type a int: true
	case a0 a[0], ar a[1:]: true
	case [a0, ...arest] a: a0
	case {key: value string} s: value
	case v a.value: true
	case v a.symbol(b): true
	default: false
}

match type a {
	case int: true
	case [int]: true
	default: false
}

// --

// what is it, a send or a receive?
// can default to send, and receive can be enforced with the optional =
let~ c1 <>
let c2 <>
select {
	c1 <- c2: // sends c2 through c1
	c1 = <-c2: // receives from c2 and captures in a new c1
	let c1 = <-c2: // receives from c2 and captures in a new c1 (full format)
}

// --

// channels for every IO? No.

type stdin fn(int) string|error
type stdout fn(string) error
type stderr fn(string) error

// --

// objects:

let ~ a 1
set a 2

fn newPair(a, b) {
	let p ~{a: a, b: b}
	fn privateFunction(v) log(v)

	return {
		getA: fn() p.a
		setA: fn(a) {
			privateFunction(a)
			p.a = a
		}
		getB: fn() p.b
		setB: fn(b) p.b = b
	}
}

// or?

fn newPair(a, b) {
	let p ~{a: a, b: b}
	fn privateFunction(v) { log("setting a" v) }

	{ getA: fn() p.a
	  setA: fn(a) {
	  	privateFunction(a)
	  	p.a = a
	  }
	  getB: fn() p.b
	  setB: fn(b) p.b = b
	}

	// we need a pretty syntax for the structure literal
}

fn f(m s) s.a > 0 ? m * s.a : s.b
f(2 a:1 b:2)

// careful with this construct because it can conflict with the range expression and the tertiary if

let p newPair(1, 2)
p.getA()

// maybe should enforce return in blocks
// switch could not be a value

fn extendedPair(a, b) {
	let p newPair(a, b)
	return {
		p...
		setB: fn(b) p.setB(2 * b)
	}
}

// function application:

f(a)
// or:
a -> f

f(g(a))
// or:
g(a) -> f
// or:
a -> g -> f

f(a b c)
// or:
c -> f(a b)

// partial application:

fn (
	f(ff, a) a -> ff
	g(a, b) [a b]
)

// fn (b) [a b]
f(g(a))
a -> g -> f

// custom types, not supported in the first round:

let type maybe just a | nothing
let type money dollar int | euro int

// --

fn hasWhitespace list.some(fn (def) def.commitType & Whitespace != 0)
