// -- http listener

import http "mml/http"

type handler http.handler

fn~ handler(w, _) {
	fprintln(w, "Hello, world!")
}

http.listen(":8080", handler)

// -- proc every number in an arbitrary json

fn proc(n) 2 * n

fn procInJson(j) {
	switch type j {
		case number: proc(j)
		case []: map(procInJson, j)
		case {}: mapStruct(procInJson, j)
		default: j
	}
}

switch {
	case true: 1
	case v == 1: 2
	case match(l[0]): 3
	case a = l[0]: 4
	case match(a = l[0]): 5
	case a = l[0], b = l[1:]: 6
	case v == 2, v == 3, v == 4: 7
	case match(s.a): 8
	case match(s["a"]): 9
	case a = s.a: 10
	case _ = s.a: 11
	case type v number: 12
	default: 13
}

// this is not needed
switch match {
	case l[0]: 1
	case s.a: 2
	default: 3
}

switch type v {
	case number: 1
	default: 2
}

swtich v {
	case 0: 1
	default: 2
}

// -- loops

let l = [1, 2, 3]

for v in l {
	print(v)
}

for i in 0:len(l) {
	print(l[i])
}

let~ ml = [1, 2, 3]

for len(ml) > 0 {
	print(ml[0])
	ml = ml[1:]
}

for {
	if len(ml) == 0 {
		break
	}

	print(ml[0])
	ml = ml[1:]
}

let s = {a: 1, b: 2, c: 3}

for v in s {
	print(v)
}

for k in keys(s) {
	print(s[k])
}

// canonically:
each(print, l)
each(print, s)

// -- matches

// match() can be used as a boolean expression, should it?

let l = [1, 2, 3]

a = l[0] ? a : 0

fn filterNumbers(l) a = l[0], rest = l[1:] ?
	type a number ?
		[a, filterNumbers(rest)...] :
		filterNumbers(rest) :
	[]

fn filterNumbers(l) {
	if a = l[0], rest = l[1:] {
		let frest = filterNumbers(rest)
		type a number ? [a, frest...] : frest
	} else {
		[]
	}
}

fn filterNumbersLoop(l) {
	let~ ml = []
	for n in l {
		if type n number {
			ml = [ml..., n]
		}
	}

	ml
}

let filterNumbersCanon = bind(filter, isNumber)

switch {
	case a == 1: a + 1
	case match(a {foo: number}): a.foo
	case n = a[0]: n
	case n = <-a: n // here and in ifs, match is optional
	default: 0
}

// -- lists

fn reverse(l)
	match(first = l[0], rest = l[1:]) ?
		[reverse(rest)..., first] :
		[]

fn reverse(l) {
	if case first = l[0], rest = l[1:] {
		[reverse(rest)..., first]
	} else {
		[]
	}
}

// should use ^ rather instead of ~, and use pow() for power of
fn reverseLoop(l) {
	let r = ~[l...]
	for i in 0:len(r) / 2 {
		let~ a = r[i]
		r[i] = r[len(r) - i]
		r[len(r) - i] = a
	}

	[r...] // the result is converted into an immutable list
}

// -- structures

let s1 = {s0..., mark: true}

// functions

fn emptyStructure() {{}}
