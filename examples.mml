fn doSomethingSafe() {
	try {
		doSomething()
	} catch (err) {
		handleError(err)
	} finally {
		finalizeBlock()
	}
}

fn doSomethingSafe() {
	defer finalizeBlock()
	defer recover(handleError)
	doSomething()
}

fn~ makeRequestSafe() {
	try {
		let rsp http.request("http://localhost:9090")
		try {
			handleResponse(rsp)
		} finally {
			rsp.close()
		}
	} catch (err) {
		handleError(err)
	}
}

fn~ makeRequestSafe() {
	defer recover(fn (err) {;})
	let rsp http.request("http://localhost:9090")
	defer rsp.close()
	handleResponse(rsp)
}

for a in b 

fn fib(n) n <= 1 ? 1 : fib(n - 1) + fib(n)

// --

// Why no null? Depends on what we want to do with the result. Let's consider the use case of finding something
// in a list.

// use case:
let null {}
fn find(cond, l) len(l) == 0 ? null : cond(l[0]) ? l[0] : find(cond, l[1:])

// use it for something:
fn~ printFirstEven(l) {
	let result find(even, l)
	if result == null {
		println("not found")
		return
	}

	println(result)
}

// in MML:
fn find(cond, l) len(l) == 0 ? [] : cond(l[0]) ? l : find(cond, l[1:])

// use it for something:
fn~ printFirstEven(l) {
	let result find(even, l)
	if len(result) == 0 {
		println("not found")
		return
	}

	println(result[0])
}

// or rather the whole thing in a more MML like style:
fn~ printFirstEven(l) {
	for n in l {
		if even(n) {
			println(n)
			return
		}
	}

	println("not found")
}

// --

// need to detect on receive when it is closed, or not use close():
let c bufchan(1)
send c 42
close(c)
let ftytwo receive c
let closed receive c

let (
	closed {}
	feed chan()
	response chan()
)

go fn () {
	let ~ sum 0
	for {
		let v receive feed
		if v == closed {
			send response sum
			return
		}

		set sum sum + v
	}
}()

for v in [1, 2, 3] {
	send feed v
}

send feed closed
println(receive response)

// --

#! /usr/bin/mml

require (
	. "os"
	. "mml"
)

for {
	stdin
	-> read
	-> eval
	-> passErr(write(stdout))
	-> onlyErr(write(stderr))
}

// -- reverse string ugly:

fn reverseString(s) {
	let ~ r ""
	for c in s {
		r = r + c
	}

	return r
}

// -- reverse string recursor instinct:

fn reverseString(s) len(s) == 0 ? "" : reverseString(s[1:]) + s[0]

// -- reverse string:

fn reverseString(s) s -> split("") -> foldr(append, "") -> join("") // not good
