use (
	. "lang"
	  "compile"
	  "parse"
)

let builtin {
	len:        "Len"
	isError:    "IsError"
	keys:       "Keys"
	format:     "Format"
	stdin:      "Stdin",
	stdout:     "Stdout"
	stderr:     "Stderr"
	string:     "String"
	has:        "Has"
	isBool:     "IsBool"
	isInt:      "IsInt"
	isFloat:    "IsFloat"
	isString:   "IsString"
	error:      "Error"
	panic:      "Panic"
	open:       "Open"
	close:      "Close"
	args:       "Args"
	parseAST:   "ParseAST"
	parseInt:   "ParseInt"
	parseFloat: "ParseFloat"
}

let builtins builtin
-> keys
-> sort(fn (left, right) left < right)
-> map(fn (k) formats("var _%s interface{} = mml.%s", k, builtin[k]))
-> join(";\n")

let head "// Generated code
package main

import \"github.com/aryszka/mml\"
"

let initHead "
func init() {
	var modulePath string
"

let initFooter "
}
"

let setModuleHead "
	mml.Modules.Set(modulePath, func() map[string]interface{} {
		exports := make(map[string]interface{})

		var c interface{}
		mml.Nop(c)
"

let setModuleFooter "
		return exports
	})
"

let mainHead "
func main() {
	mml.Modules.Use(\""

let mainFooter "\")
}
"

fn compileModuleCode(moduleCode) {
	stdout(formats("modulePath = \"%s\"", moduleCode.path))
	stdout(setModuleHead)
	moduleCode
	-> compile.compile
	-> passErr(stdout)
	-> onlyErr(log)
	stdout(setModuleFooter)
}

fn compileModules(m) {
	for mi in m {
		compileModuleCode(mi)
	}
}

let modules parse.parseModules(args[1])
if isError(modules) {
	panic(modules)
}

stdout(head)
stdout(builtins)
stdout(initHead)
compileModules(modules)
stdout(initFooter)
stdout(mainHead)
stdout(args[1])
stdout(mainFooter)
