use (
	. "lang"
	  "compile"
	  "parse"
	  "code"
	  "definitions"
)

let builtins code.builtin
-> keys
-> sort(fn (left, right) left < right)
-> map(fn (k) formats("var _%s interface{} = mml.%s", k, code.builtin[k]))
-> join(";\n")

let head "// Generated code
package main

import \"github.com/aryszka/mml\"
"

let initHead "
func init() {
	var modulePath string
"

let initFooter "
}
"

let setModuleHead "
	mml.Modules.Set(modulePath, func() map[string]interface{} {
		exports := make(map[string]interface{})

		var c interface{}
		mml.Nop(c)
"

let setModuleFooter "
		return exports
	})
"

let mainHead "
func main() {
	mml.Modules.Use(\""

let mainFooter "\")
}
"

fn validateDefinitions(modules) {
	let ~ hasErrors false
	for m in modules {
		let errors definitions.validate(m)
		if len(errors) > 0 {
			hasErrors = true
			log(formats("%s:", m.path))
			for e in errors {
				log(e)
			}
		}
	}

	if hasErrors {
		return error("undefined reference(s) found")
	}
}

fn compileModuleCode(moduleCode) {
	stdout(formats("modulePath = \"%s\"", moduleCode.path))
	stdout(setModuleHead)
	moduleCode
	-> compile.do
	-> passErr(stdout)
	-> onlyErr(log)
	stdout(setModuleFooter)
}

fn compileModules(m) {
	for mi in m {
		compileModuleCode(mi)
	}
}

let modules parse.modules(args[1])
if isError(modules) {
	panic(modules)
}

let validation validateDefinitions(modules)
if isError(validation) {
	panic(validation)
}

stdout(head)
stdout(builtins)
stdout(initHead)
compileModules(modules)
stdout(initFooter)
stdout(mainHead)
stdout(args[1])
stdout(mainFooter)
