// input: a reader, and a definition list
// output: the tokens

// whitespace: charclass considered as whitespace
// primitive: fixed tokens
//
// delimited:
// - delimited tokens, other rules don't apply inside
// - left delimiter primitive|charclass list|expression
// - right delimiter primitive|charclass list|expression
// - escape: escape charclass list, escapable charclass list
// - banned charclass
// - allowed charclass
//
// charclass list: characters matching, escape charclass and escapable
// expression: expression matching
//
// how to handle transient error: return short read

fn ~ delimiterReader(readInput, def, chars) {
	let ~ (
		started false
		readChars chars
		token ""
		escaped false
		currentEscape fn() {err: noError}
		escapeToken ""
	)

	fn ~ startToken() {
		let (
			readDelimiter readerByType(readInput, def.leftDelimiter, readChars)
			result readDelimiter()
		)

		set readChars result.chars
		switch {
		case isError(result.err):
			result
		default:
			set started true
			set token result.token
			read()
		}
	}

	fn ~ readEscape(escapes) {
		if or(escaped, len(escapes) == 0) {
			{err: errNoMatch, chars: readChars}
		} else {
			let (
				readEscape readerByType(readInput, escapes[0].escape, readChars)
				result readEscape()
			)

			set readChars result.chars
			switch {
			case result.err == eof:
				{err: errInvalidSequence, chars: readChars}
			case result.err == errNoMatch:
				readEscape(escapes[1:])
			case isError(result.err):
				result
			default:
				set escaped true
				set currentEscape escapes[0].escapable // should be any char if not defined
				set escapeToken result.token
				{err: noError, chars: readChars}
			}
		}
	}

	fn ~ readEscaped() {
		let (
			readEscaped readerByType(readInput, currentEscape, readChars)
			result readEscaped()
		)

		set readChars result.chars
		switch {
		case result.err == eof:
			{err: errInvalidSequence, chars: readChars}
		case result.err == errNoMatch:
			{err: errInvalidEscape, chars: readChars}
		case isError(result.err):
			result
		default:
			set token appendString(token, escapeToken, result.token)
			set escaped false
			read()
		}
	}

	fn ~ readBanned(banned) {
		if len(banned) == 0 {
			{err: noError, chars: readChars}
		} else {
			let (
				readBanned readerByType(readInput, banned[0], readChars)
				result readBanned()
			)

			set readChars result.chars
			switch {
			case result.err == errNoMatch:
				readBanned(banned[1:])
			case isError(result.err):
				result
			default:
				{err: errInvalidSequence, chars: readChars}
			}
		}
	}

	fn ~ readAllowed(allowed) {
		if len(allowed) == 0 {
			{err: errInvalidSequence, chars: readChars}
		} else {
			let (
				readAllowed readerByType(readInput, allowed[0], readChars)
				result readAllowed()
			)

			set readChars result.chars
			switch {
			case result.err == eof:
				{err: errInvalidSequence, chars: readChars}
			case result.err == errNoMatch:
				readAllowed(allowed[1:])
			case isError(result.err):
				result
			default:
				set token appendString(token, result.token)
				read()
			}
		}
	}

	fn ~ readNormal() {
		let result readBanned(def.banned)
		switch {
		case isError(result.err):
			result
		default:
			readAllowed(def.allowed) // should contain any char if nothing else was set
		}
	}

	fn ~ readBody() {
		let result readEscape(def.escapes)
		switch {
		case result.err == errNoMatch:
			if escaped {
				readEscaped()
			} else {
				readNormal()
			}
		case isError(result.err):
			result
		default:
			read() // TODO: optimize, this now means recursion for the full delimited block
		}
	}

	fn ~ readStarted() {
		let (
			chars if escaped { appendString(escapeToken, readChars) } else { readChars }
			readDelimiter readerByType(readInput, def.rightDelimiter, chars)
			result readDelimiter()
		)

		set readChars result.chars
		switch {
		case result.err == eof:
			{err: errInvalidSequence, chars: readChars}
		case result.err == errNoMatch:
			readBody()
		case isError(result.err):
			result
		default:
			set token appendString(token, result.token)
			{err: noError, token: token, chars: readChars}
		}
	}

	fn ~ read() {
		switch {
		case not(started):
			startToken()
		default:
			readStarted()
		}
	}

	read
}

// should allow alternatives with the same name
fn groupDefs(defs) {
	reduceStruct(fn (name, def, result) {
		result...
		[def.typ]: match {
			case existing result[def.typ]:
				{existing..., [name]: def}
			default: {[name]: def}
		}
	}, {}, defs)
}

fn isWhitespace(defs, c) {
	structSome(
		fn (_, def) stringContains(def.chars, c)
		defs.whitespace
	)
}

// maybe oo would be better

# not expected

fn ~ next(state) {
	let c state.read(1)
	switch {
		case c == "":
			set state.err errShortRead
		case state.delimited:
			readDelimited(state, c)
		case isWhitespace(c):
			checkFinishCurrent(state, c)
		case isDelimiter(c):
			checkFinishCurrent(state, c)
			setDelimited(state, c)
	}
}

fn ~ init(read, defs) {
	let state ~{
		read: read
		defs: groupDefs(defs)
	}

	fn ~ () next(state)
}
