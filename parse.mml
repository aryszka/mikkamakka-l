use (
	. "lang"
	  "code"
	  "strings"
	  "errors"
)

fn (
	parseString(ast)             strings.unescape(ast.text[1:len(ast.text) - 1])
	parseSpread(ast)             {type: "spread", value: parse(ast.nodes[0])}
	parseExpressionList(nodes)   map(parse, nodes)
	parseList(ast)               {type: "list", values: parseExpressionList(ast.nodes), mutable: false}
	parseMutableList(ast)        {parseList(ast)..., mutable: true}
	parseExpressionKey(ast)      {type: "expression-key", value: parse(ast.nodes[0])}
	parseEntry(ast)              {type: "entry", key: parse(ast.nodes[0]), value: parse(ast.nodes[1])}
	parseStruct(ast)             {type: "struct", entries: map(parse, ast.nodes), mutable: false}
	parseMutableStruct(ast)      {parseStruct(ast)..., mutable: true}
	parseStatementList(ast)      {type: "statement-list", statements: map(parse, ast.nodes)}
	parseFunction(ast)           parseFunctionFact(ast.nodes)
	parseEffect(ast)             {parseFunction(ast)..., effect: true}
	parseSymbolIndex(ast)        parse(ast.nodes[0]).name
	parseExpressionIndex(ast)    parse(ast.nodes[0])
	parseIndexer(ast)            parseIndexerNodes(ast.nodes)
	parseMutableCapture(ast)     {parseValueCapture(ast)..., mutable: true}
	parseValueDefinition(ast)    parse(ast.nodes[0])
	parseFunctionDefinition(ast) parse(ast.nodes[0])
	parseAssign(ast)             {type: "assign-list", assignments: parseAssignCaptures(ast.nodes)}
	parseSend(ast)               {type: "send", channel: parse(ast.nodes[0]), value: parse(ast.nodes[1])}
	parseReceive(ast)            {type: "receive", channel: parse(ast.nodes[0])}
	parseGo(ast)                 {type: "go", application: parse(ast.nodes[0])}
	parseDefer(ast)              {type: "defer", application: parse(ast.nodes[0])}
	parseReceiveDefinition(ast)  parseValueCapture(ast)
)

fn parseSymbol(ast) {
	switch ast.text {
	case "break":
		return {type: "control-statement", control: code.breakControl}
	case "continue":
		return {type: "control-statement", control: code.continueControl}
	// TODO: all the keywords
	default:
		return {type: "symbol", name: ast.text}
	}
}

fn parseReturn(ast) len(ast.nodes) == 0 ? {type: "ret"} : {type: "ret", value: parse(ast.nodes[0])}

fn parseFunctionFact(nodes) {
	let (
		last len(nodes) - 1
		params nodes[:last]
		lastParam len(params) - 1
		hasCollectParam len(params) > 0 && params[lastParam].name == "collect-parameter"
		fixedParams hasCollectParam ? params[:lastParam] : params
	)

	return {
		type:         "function"
		params:       fixedParams -> map(parse) -> map(fn (p) p.name)
		collectParam: hasCollectParam ? parse(params[lastParam].nodes[0]).name : ""
		statement:    parse(nodes[last])
		effect:       false
	}
}

fn parseRange(ast) {
	let v = parse(ast.nodes[0])
	return ast.name == "range-from" ? {
		type: "range-expression"
		from: v
	} : {
		type: "range-expression"
		to: v
	}
}

fn parseRangeIndex(ast) {
	if len(ast.nodes) == 0 {
		return {type: "range-expression"}
	}

	let r parse(ast.nodes[0])
	if len(ast.nodes) == 1 {
		return r
	}

	return {r..., to: parse(ast.nodes[1]).to}
}

fn parseIndexerNodes(n) {
	type:       "indexer"
	expression: len(n) == 2 ? parse(n[0]) : parseIndexerNodes(n[:len(n) - 1])
	index:      parse(n[len(n) - 1])
}

fn parseFunctionApplication(ast) {
	type:     "function-application"
	function: parse(ast.nodes[0])
	args:     parseExpressionList(ast.nodes[1:])
}

fn parseUnaryExpression(ast) {
	let ~ op code.binaryNot
	switch ast.nodes[0].name {
	case "plus":
		op = code.plus
	case "minus":
		op = code.minus
	case "logical-not":
		op = code.logicalNot
	}

	return {
		type: "unary"
		op:   op
		arg:  parse(ast.nodes[1])
	}
}

fn parseBinaryExpression(ast) {
	let ~ op code.binaryAnd
	switch ast.nodes[len(ast.nodes)-2].name {
	case "xor":
		op = code.xor
	case "and-not":
		op = code.andNot
	case "lshift":
		op = code.lshift
	case "rshift":
		op = code.rshift
	case "mul":
		op = code.mul
	case "div":
		op = code.div
	case "mod":
		op = code.mod
	case "add":
		op = code.add
	case "sub":
		op = code.sub
	case "eq":
		op = code.eq
	case "not-eq":
		op = code.notEq
	case "less":
		op = code.less
	case "less-or-eq":
		op = code.lessOrEq
	case "greater":
		op = code.greater
	case "greater-or-eq":
		op = code.greaterOrEq
	case "logical-and":
		op = code.logicalAnd
	case "logical-or":
		op = code.logicalOr
	}

	return {
		type:  "binary"
		op:    op
		left:  parse(len(ast.nodes) > 3 ?
			{
				name:  ast.name
				nodes: ast.nodes[:len(ast.nodes) - 2]
			} :
			ast.nodes[0])
		right: parse(ast.nodes[len(ast.nodes) - 1])
	}
}

fn parseChaining(ast) {
	let (
		~ a parse(ast.nodes[0])
		~ n ast.nodes[1:]
	)

	for {
		if len(n) == 0 {
			return a
		}

		a = {
			type:     "function-application"
			function: parse(n[0])
			args:     [a]
		}

		n = n[1:]
	}
}

fn parserTernary(ast) {
	type:        "cond"
	condition:   parse(ast.nodes[0])
	consequent:  parse(ast.nodes[1])
	alternative: parse(ast.nodes[2])
	ternary:     true
}

fn parseIf(ast) {
	let cond {
		type:       "cond"
		ternary:    false
		condition:  parse(ast.nodes[0])
		consequent: parse(ast.nodes[1])
	}

	if len(ast.nodes) == 2 {
		return cond
	}

	let alternative len(ast.nodes) == 3 ?
		parse(ast.nodes[2]) :
		parse({ast..., nodes: ast.nodes[2:]})

	return {
		cond...
		alternative: alternative
	}
}

fn parseSwitch(ast) {
	let (
		hasExpression ast.nodes[0].name != "case" && ast.nodes[0].name != "default"
		expression    hasExpression ? ast.nodes[0] : {}
		nodes         hasExpression ? ast.nodes[1:] : ast.nodes
	)

	fn groupLines() {
		let ~ (
			isDefault false
			current   []
			cases     []
			defaults  []
		)

		for n in nodes {
			switch n.name {
			case "case":
				if len(current) > 0 {
					if isDefault {
						defaults = current
					} else {
						cases = [cases..., current]
					}
				}

				current = [n.nodes[0]]
				isDefault = false
			case "default":
				if len(current) > 0 && !isDefault {
					cases = [cases..., current]
				}

				current = []
				isDefault = true
			default:
				current = [current..., n]
			}
		}

		if len(current) > 0 {
			if isDefault {
				defaults = current
			} else {
				cases = [cases..., current]
			}
		}

		return {cases: cases, defaults: defaults}
	}

	fn parseCases(c) {
		return map(fn (c) {
			type:       "switch-case"
			expression: parse(c[0])
			body:       {
				type:       "statement-list"
				statements: map(parse, c[1:])
			}
		}, c)
	}

	let lines groupLines()
	let s {
		type:              "switch-statement"
		cases:             parseCases(lines.cases)
		defaultStatements: {type: "statement-list", statements: map(parse, lines.defaults)}
	}

	return hasExpression ? {s..., expression: parse(expression)} : s
}

fn parseRangeOver(ast) {
	if len(ast.nodes) == 0 {
		return {type: "range-over"}
	}

	if len(ast.nodes) == 1 && ast.nodes[0].name == "symbol" {
		return {
			type:   "range-over"
			symbol: parse(ast.nodes[0]).name
		}
	}

	fn parseExpression(nodes) {
		let exp parse(nodes[0])
		if !has("type", exp) || exp.type != "range-expression" || len(nodes) == 1 {
			return exp
		}

		return {
			exp...
			to: parse(nodes[1]).to
		}
	}

	if ast.nodes[0].name != "symbol" {
		return {
			type:       "range-over"
			expression: parseExpression(ast.nodes)
		}
	}

	return {
		type:       "range-over"
		symbol:     parse(ast.nodes[0]).name
		expression: parseExpression(ast.nodes[1:])
	}
}

fn parseLoop(ast) {
	let loop {type: "loop"}
	if len(ast.nodes) == 1 {
		return {loop..., body: parseStatementList(ast.nodes[0])}
	}

	let expression parse(ast.nodes[0])
	let emptyRange
		has("type", expression) &&
		expression.type == "range-over" &&
		!has("symbol", expression) &&
		!has("expression", expression)
	
	return emptyRange ?
		{loop..., body: parseStatementList(ast.nodes[1])} :
		{loop..., expression: expression, body: parseStatementList(ast.nodes[1])}
}

fn parseValueCapture(ast) {
	type:       "definition"
	symbol:     parse(ast.nodes[0]).name
	expression: parse(ast.nodes[1])
	mutable:    false
	exported:   false
}

fn parseDefinitions(ast) {
	type:        "definition-list"
	definitions: ast.nodes
		-> map(parse)
		-> filter(fn (c) !has("type", c) || c.type != "comment")
}

fn parseMutableDefinitions(ast) {
	let dl parseDefinitions(ast)
	return {
		dl...
		definitions: dl.definitions -> map(fn (d) {d..., mutable: true})
	}
}

fn parseFunctionCapture(ast) {
	type:       "definition"
	symbol:     parse(ast.nodes[0]).name
	expression: parseFunctionFact(ast.nodes[1:])
	exported:   false
}

fn parseEffectCapture(ast) {
	let f parseFunctionCapture(ast)
	return {
		f...
		expression: {f.expression..., effect: true}
	}
}

fn parseEffectDefinitions(ast) {
	let dl parseDefinitions(ast)
	return {
		dl...
		definitions: map(fn (d) {d..., effect: true}, dl.definitions)
	}
}

fn parseAssignCaptures(nodes) {
	if len(nodes) == 0 {
		return []
	}

	return [
		{
			type:    "assign"
			capture: parse(nodes[0])
			value:   parse(nodes[1])
		}
		parseAssignCaptures(nodes[2:])...
	]
}

fn parseSelect(ast) {
	let nodes ast.nodes

	fn groupLines() {
		let ~ (
			isDefault  false
			hasDefault false
			current    []
			cases      []
			defaults   []
		)

		for n in nodes {
			switch n.name {
			case "case":
				if len(current) > 0 {
					if isDefault {
						defaults = current
					} else {
						cases = [cases..., current]
					}
				}

				current = [n.nodes[0]]
				isDefault = false
			case "default":
				if len(current) > 0 && !isDefault {
					cases = [cases..., current]
				}

				current = []
				isDefault = true
			default:
				current = [current..., n]
			}
		}

		if len(current) > 0 {
			if isDefault {
				defaults = current
			} else {
				cases = [cases..., current]
			}
		}

		return {cases: cases, defaults: defaults, hasDefault: hasDefault}
	}

	fn parseCases(c) {
		return map(fn (c) {
			type:       "select-case"
			expression: parse(c[0])
			body:       {
				type:       "statement-list"
				statements: map(parse, c[1:])
			}
		}, c)
	}

	let lines groupLines()
	return {
		cases:             parseCases(lines.cases)
		defaultStatements: {type: "statement-list", statements: map(parse, lines.defaults)}
		hasDefault:        lines.hasDefault
	}
}

fn parseExport(ast) {
	let d parse(ast.nodes[0])
	return {
		type: "definition-list"
		definitions:
			(d.type == "definition" ? [d] : d.definitions)
			-> map(fn (d) {d..., exported: true})
	}
}

fn parseUseFact(ast) {
	let (
		~ capture ""
		~ path    ""
	)

	switch ast.nodes[0].name {
	case "use-inline":
		capture = "."
		path = parse(ast.nodes[1])
	case "symbol":
		capture = parse(ast.nodes[0]).name
		path = parse(ast.nodes[1])
	default:
		path = parse(ast.nodes[0])
	}

	return {
		type:    "use"
		capture: capture
		path:    path
	}
}

fn parseUse(ast) {
	type: "use-list"
	uses: map(parse, ast.nodes)
}

fn parse(ast) {
	switch ast.name {
	case "line-comment-content":
		return {type: "comment"}
	case "int":
		return parseInt(ast.text)
	case "float":
		return parseFloat(ast.text)
	case "string":
		return parseString(ast)
	case "true":
		return true
	case "false":
		return false
	case "symbol":
		return parseSymbol(ast)
	case "spread-expression":
		return parseSpread(ast)
	case "list":
		return parseList(ast)
	case "mutable-list":
		return parseMutableList(ast)
	case "expression-key":
		return parseExpressionKey(ast)
	case "entry":
		return parseEntry(ast)
	case "struct":
		return parseStruct(ast)
	case "mutable-struct":
		return parseMutableStruct(ast)
	case "return":
		return parseReturn(ast)
	case "block":
		return parseStatementList(ast)
	case "function":
		return parseFunction(ast)
	case "effect":
		return parseEffect(ast)
	case "range-from":
		return parseRange(ast)
	case "range-to":
		return parseRange(ast)
	case "symbol-index":
		return parseSymbolIndex(ast)
	case "expression-index":
		return parseExpressionIndex(ast)
	case "range-index":
		return parseRangeIndex(ast)
	case "indexer":
		return parseIndexer(ast)
	case "function-application":
		return parseFunctionApplication(ast)
	case "unary-expression":
		return parseUnaryExpression(ast)
	case "binary0":
		return parseBinaryExpression(ast)
	case "binary1":
		return parseBinaryExpression(ast)
	case "binary2":
		return parseBinaryExpression(ast)
	case "binary3":
		return parseBinaryExpression(ast)
	case "binary4":
		return parseBinaryExpression(ast)
	case "chaining":
		return parseChaining(ast)
	case "ternary-expression":
		return parserTernary(ast)
	case "if":
		return parseIf(ast)
	case "switch":
		return parseSwitch(ast)
	case "range-over-expression":
		return parseRangeOver(ast)
	case "loop":
		return parseLoop(ast)
	case "value-capture":
		return parseValueCapture(ast)
	case "mutable-capture":
		return parseMutableCapture(ast)
	case "value-definition":
		return parseValueDefinition(ast)
	case "value-definition-group":
		return parseDefinitions(ast)
	case "mutable-definition-group":
		return parseMutableDefinitions(ast)
	case "function-capture":
		return parseFunctionCapture(ast)
	case "effect-capture":
		return parseEffectCapture(ast)
	case "function-definition":
		return parseFunctionDefinition(ast)
	case "function-definition-group":
		return parseDefinitions(ast)
	case "effect-definition-group":
		return parseEffectDefinitions(ast)
	case "assignment":
		return parseAssign(ast)
	case "send":
		return parseSend(ast)
	case "receive":
		return parseReceive(ast)
	case "go":
		return parseGo(ast)
	case "defer":
		return parseDefer(ast)
	case "receive-definition":
		return parseReceiveDefinition(ast)
	case "select":
		return parseSelect(ast)
	case "export":
		return parseExport(ast)
	case "use-fact":
		return parseUseFact(ast)
	case "use":
		return parseUse(ast)
	default:
		return parseStatementList(ast)
	}
}

fn parseFile(path) {
	let in open(path)
	if isError(in) {
		return in
	}

	defer close(in)

	let ast in(-1) -> passErr(parseAST)
	if isError(ast) {
		return ast
	}

	return parse(ast)
}

// TODO: can there be an export below the top level?

fn findExportNames(statements)
	statements
	-> code.flattenedStatements("definition", "definition-list", "definitions")
	-> filter(fn (d) d.exported)
	-> map(fn (d) d.symbol)

export fn parseModules(path) {
	// TODO:
	// - this only considers the top level uses, while it is allowed to have lower level uses

	let (
		module parseFile(path)
		uses   code.flattenedStatements("use", "use-list", "uses", module.statements)
	)

	if isError(module) {
		return module
	}

	let usesModules uses
	-> map(fn (u) u.path + ".mml")
	-> map(parseModules)
	-> errors.any
	-> passErr(flat)
	-> passErr(map(fn (m) {
		type: m.type
		path: m.path
		statements: m.statements
		exportNames: findExportNames(m.statements)
	}))

	if isError(usesModules) {
		return usesModules
	}

	let statements module.statements
	-> map(fn (s) {
		if !has("type", s) || s.type != "use" && s.type != "use-list" {
			return s
		}

		if s.type == "use" {
			let m filter(fn (m) m.path == s.path, usesModules)
			if len(m) == 0 {
				return s
			}

			return {
				type:        s.type
				path:        s.path
				capture:     s.capture
				exportNames: m[0].exportNames
			}
		}

		return {
			type: s.type
			uses: map(fn (u) {
				let m filter(fn (m) m.path == u.path + ".mml", usesModules)
				if len(m) == 0 {
					return u
				}

				return {
					type:        u.type
					path:        u.path
					capture:     u.capture
					exportNames: m[0].exportNames
				}
			}, s.uses)
		}
	})

	let currentCode {
		type:       module.type
		path:       path
		statements: statements
	}

	return [currentCode, usesModules...]
}
