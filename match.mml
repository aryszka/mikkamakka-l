use (
	. "list"
	. "functions"
	  "ints"
	  "floats"
)

fn (
	token()      token
	none()       none
	integer()    integer
	floating()   floating
	stringType() stringType
	boolean()    boolean
	errorType()  errorType
)

export fn (
	any()      any
	function() function
	channel()  channel
)

export fn type(t) {
	switch t {
	case int:
		return integer
	case float:
		return floating
	case string:
		return stringType
	case bool:
		return boolean
	case error:
		return errorType
	default:
		return t
	}
}

fn defineType(name) {token: token, type: name}

let (
	intRangeType   defineType("int-range")
	floatRangeType defineType("float-range")
)

fn (
	isRange(ofType, min, max) ofType(min) && ofType(max) && min <= max
	isNaturalRange(min, max)  isRange(isInt, min, max) && min >= 0
)

fn defineRange(base, validate, min, max)
	validate(min, max) ?
	{base..., min: min, max: max} :
	none

let (
	intRange        defineRange(intRangeType, isRange(isInt))
	floatRange      defineRange(floatRangeType, isRange(isFloat))
	stringRangeType defineType("string")
	stringRange     defineRange(stringRangeType, isNaturalRange)
	listType        defineType("list")
)

fn listRange(item, min, max) {defineRange(listType, isNaturalRange, min, max)..., item: item}

export fn (
	listOf(item) listRange(type(item), 0, ints.max)
	structOf(s)  is({}, s) ? s : none
)

export fn range(match, min, max) {
	let m type(match)
	switch {
	case m == integer:
		return intRange(min, max)
	case m == floating:
		return floatRange(min, max)
	case m == stringType:
		return stringRange(min, max)
	case typesMatch(listType, m):
		return listRange(m.item, min, max)
	default:
		return none
	}
}

let (
	unionType     defineType("union")
	intersectType defineType("intersection")
	predicateType defineType("predicate")
)

export fn (
	or(...matches)  {unionType..., matches: map(type, matches)}
	and(...matches) {intersectType..., matches: map(type, matches)}
	predicate(p)    {predicateType..., check: p}
)

fn isSimpleType(t) some(bind(eq, t), [
	integer
	floating
	stringType
	boolean
	function
	errorType
	channel
])

fn isComplexType(t)
	isStruct(t) &&
	has("token", t) && t.token == token &&
	has("type", t) && isString(t.type)

fn isType(t) isSimpleType(t) || isComplexType(t)

fn typesMatch(type, value)
	isComplexType(type) &&
	isComplexType(value) &&
	type.type == value.type

let primitives {
	int:    {checkValue: isInt, type: integer, rangeType: intRangeType, rangeValue: identity}
	float:  {checkValue: isFloat, type: floating, rangeType: floatRangeType, rangeValue: identity}
	string: {checkValue: isString, type: stringType, rangeType: stringRangeType, rangeValue: len}
}

fn matchPrimitive(def, match, value) {
	switch {
	case !def.checkValue(value):
		return false
	case match == def.type:
		return true
	case typesMatch(def.rangeType, match):
		let rv def.rangeValue(value)
		return rv >= match.min && rv <= match.max
	default:
		return false
	}
}

let (
	matchInt    matchPrimitive(primitives.int)
	matchFloat  matchPrimitive(primitives.float)
	matchString matchPrimitive(primitives.string)
)

fn matchToList(match, value) {
	if len(value) < len(match) {
		return false
	}

	for i in :len(match) {
		if !is(match[i], value[i]) {
			return false
		}
	}

	return true
}

fn matchToListType(match, value)
	len(value) >= match.min &&
	len(value) <= match.max &&
	every(is(match.item), value)

fn matchList(match, value) {
	switch {
	case !isList(value):
		return false
	case isList(match):
		return matchToList(match, value)
	case typesMatch(listType, match):
		return matchToListType(match, value)
	default:
		return false
	}
}

fn matchStruct(match, value)
	isStruct(value) &&
	every(fn (key) has(key, value) && is(match[key], value[key]), keys(match))

fn (
	matchUnion(match, value)        some(fn (m) is(m, value), match.matches)
	matchIntersection(match, value) every(fn (m) is(m, value), match.matches)
)

fn matchOne(match, value) {
	switch {
	case match == none:
		return false
	case match == any:
		return true
	case typesMatch(predicateType, match):
		return match.check(value)
	case isType(value) && value != function:
		return false
	case match == value:
		return true
	case match == integer || typesMatch(intRangeType, match):
		return matchInt(match, value)
	case match == floating || typesMatch(floatRangeType, match):
		return matchFloat(match, value)
	case match == stringType || typesMatch(stringRangeType, match):
		return matchString(match, value)
	case match == boolean:
		return isBool(value)
	case match == function:
		return isFunction(value)
	case match == channel:
		return isChannel(value)
	case match == errorType:
		return isError(value)
	case isList(match) || typesMatch(listType, match):
		return matchList(match, value)
	case typesMatch(unionType, match):
		return matchUnion(match, value)
	case typesMatch(intersectType, match):
		return matchIntersection(match, value)
	case isStruct(match):
		return matchStruct(match, value)
	default:
		return false
	}
}

export fn is(match, ...values)
	len(values) == 0 ?
	bind(is, match) :
	every(matchOne(match), values)
