#! /usr/bin/mml

/*
I want to find a note taken in the topic of Kubernetes and I am sure that there is such a text file somewhere in
my home directory. I am not sure if I wrote kube, Kube, kubernetes or Kubernetes, but I don't want to find notes
with sudokube, MakubeX or anything else. I have a lot of notes with Kubernetes, and I want to list those that
are closest to a date 9 months ago, and they're max 14 months old. I want to prioritize them by the frequency
they mention Kubernetes. I also want to prioritize those notes whose path contains something with Kubernetes,
and those, too, that are in my ~/Work or ~/doc directory. And of course I don't want to list code or config
files, and I know that I use C, Go, JS, mml, Haskell, Elm, and I probably have some Python scripts on my disk
from so many lucky friends of mine, too, and there can be config files of JSON and unfortunately YAML, too.
*/

require (
	"list"
	"math"
	"regexp"
	"script"
	"strings"
	"struct"
	"time"
)

// os functions will panic on error:
let os script.requireModule("os")

let (
	matchExpression   "[^a-zA-Z]kube(rnetes)?"
	findKube          regexp.mustCompile(matchExpression)
	matchKube         regexp.mustCompile("^" + matchExpression + "$")
)

fn monthsAgo(m) time.add(time.now(), m * -30 * 24 * time.hour)

fn codeFile(f) list.some(
	eq(path.extension(f.path))
	["c", "h", "go", "js", "mml", "hs", "elm", "json", "py", "yaml", "yml"]
)

fn old(f) time.less(f.date, monthsAgo(14))

fn ~ (
	containsKube(f) f -> os.read -> strings.toLower -> findKube.match
	fileMatch(f)    !f.isDir && !old(f) && !codeFile(f) && containsKube(f)
)

fn ~ findFiles(dir) {
	let (
		files        os.readDir(dir)
		matches      list.effect.filter(fileMatch, files)
		dirs         list.filter(struct.get("isDir"), files)
		childMatches list.effect.map(findFiles, dirs)
	)

	return list.cat(matches, childMatches...)
}

fn lessByDate(left, right) {
	fn diff(f) f.date -> time.sub(monthsAgo(9)) -> math.abs
	return diff(left) < diff(right)
}

fn ~ lessByFrequency(left, right) {
	fn ~ count(f) f -> os.read -> findKube.all -> len
	return count(left) > count(right)
}

fn lessByKubeInPath(left, right) {
	fn count(p) fold(
		fn (tag, count) matchKube.match(tag) ? count + 1 : count
		0
		strings.split(strings.toLower(p), "/")
	)

	return count(left.path) > count(right.path)
}

fn lessByTopDir(left, right) {
	fn hasTopDir(p) switch names strings.split(p, "/") {
		case topDir names[3]: topDir == "Work" || topDir == "doc"
		default: false
	}

	return hasTopDir(left.path) && !hasTopDir(right.path)
}

fn ~ sort list.effect.quickSort(
	fn (left, right) list.effect.some(
		fn (less) less(left, right)
		[lessByDate, lessByFrequency, lessByKubeInPath, lessByTopDir]
	)
)

"~" -> findFiles -> sort -> list.effect.map(println)
